{"ast":null,"code":"import _slicedToArray from \"D:/TODO_new/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"D:/TODO_new/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectWithoutProperties from \"D:/TODO_new/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _defineProperty from \"D:/TODO_new/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"D:/TODO_new/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _TYPE_STATICS;\nvar _excluded = [\"initMapStateToProps\", \"initMapDispatchToProps\", \"initMergeProps\"],\n  _excluded2 = [\"reactReduxForwardedRef\"];\n// src/index.ts\nimport * as React2 from \"react\";\nimport { useSyncExternalStoreWithSelector as useSyncExternalStoreWithSelector2 } from \"use-sync-external-store/with-selector.js\";\n\n// src/utils/react.ts\nimport * as ReactOriginal from \"react\";\nvar React =\n// prettier-ignore\n// @ts-ignore\n\"default\" in ReactOriginal ? ReactOriginal[\"default\"] : ReactOriginal;\n\n// src/components/Context.ts\nvar ContextKey = Symbol.for(\"react-redux-context\");\nvar gT = typeof globalThis !== \"undefined\" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */\n{};\nfunction getContext() {\n  var _gT$ContextKey;\n  if (!React.createContext) return {};\n  var contextMap = (_gT$ContextKey = gT[ContextKey]) !== null && _gT$ContextKey !== void 0 ? _gT$ContextKey : gT[ContextKey] = /* @__PURE__ */new Map();\n  var realContext = contextMap.get(React.createContext);\n  if (!realContext) {\n    realContext = React.createContext(null);\n    if (process.env.NODE_ENV !== \"production\") {\n      realContext.displayName = \"ReactRedux\";\n    }\n    contextMap.set(React.createContext, realContext);\n  }\n  return realContext;\n}\nvar ReactReduxContext = /* @__PURE__ */getContext();\n\n// src/utils/useSyncExternalStore.ts\nvar notInitialized = function notInitialized() {\n  throw new Error(\"uSES not initialized!\");\n};\n\n// src/hooks/useReduxContext.ts\nfunction createReduxContextHook() {\n  var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  return function useReduxContext2() {\n    var contextValue = React.useContext(context);\n    if (process.env.NODE_ENV !== \"production\" && !contextValue) {\n      throw new Error(\"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\");\n    }\n    return contextValue;\n  };\n}\nvar useReduxContext = /* @__PURE__ */createReduxContextHook();\n\n// src/hooks/useSelector.ts\nvar useSyncExternalStoreWithSelector = notInitialized;\nvar initializeUseSelector = function initializeUseSelector(fn) {\n  useSyncExternalStoreWithSelector = fn;\n};\nvar refEquality = function refEquality(a, b) {\n  return a === b;\n};\nfunction createSelectorHook() {\n  var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  var useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n  var useSelector2 = function useSelector2(selector) {\n    var equalityFnOrOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _ref = typeof equalityFnOrOptions === \"function\" ? {\n        equalityFn: equalityFnOrOptions\n      } : equalityFnOrOptions,\n      _ref$equalityFn = _ref.equalityFn,\n      equalityFn = _ref$equalityFn === void 0 ? refEquality : _ref$equalityFn,\n      _ref$devModeChecks = _ref.devModeChecks,\n      devModeChecks = _ref$devModeChecks === void 0 ? {} : _ref$devModeChecks;\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!selector) {\n        throw new Error(\"You must pass a selector to useSelector\");\n      }\n      if (typeof selector !== \"function\") {\n        throw new Error(\"You must pass a function as a selector to useSelector\");\n      }\n      if (typeof equalityFn !== \"function\") {\n        throw new Error(\"You must pass a function as an equality function to useSelector\");\n      }\n    }\n    var _useReduxContext = useReduxContext2(),\n      store = _useReduxContext.store,\n      subscription = _useReduxContext.subscription,\n      getServerState = _useReduxContext.getServerState,\n      stabilityCheck = _useReduxContext.stabilityCheck,\n      identityFunctionCheck = _useReduxContext.identityFunctionCheck;\n    var firstRun = React.useRef(true);\n    var wrappedSelector = React.useCallback(_defineProperty({}, selector.name, function (state) {\n      var selected = selector(state);\n      if (process.env.NODE_ENV !== \"production\") {\n        var _stabilityCheck$ident = _objectSpread({\n            stabilityCheck: stabilityCheck,\n            identityFunctionCheck: identityFunctionCheck\n          }, devModeChecks),\n          finalIdentityFunctionCheck = _stabilityCheck$ident.identityFunctionCheck,\n          finalStabilityCheck = _stabilityCheck$ident.stabilityCheck;\n        if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n          var toCompare = selector(state);\n          if (!equalityFn(selected, toCompare)) {\n            var stack = void 0;\n            try {\n              throw new Error();\n            } catch (e) {\n              ;\n              stack = e.stack;\n            }\n            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\", {\n              state: state,\n              selected: selected,\n              selected2: toCompare,\n              stack: stack\n            });\n          }\n        }\n        if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n          if (selected === state) {\n            var _stack = void 0;\n            try {\n              throw new Error();\n            } catch (e) {\n              ;\n              _stack = e.stack;\n            }\n            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\", {\n              stack: _stack\n            });\n          }\n        }\n        if (firstRun.current) firstRun.current = false;\n      }\n      return selected;\n    })[selector.name], [selector, stabilityCheck, devModeChecks.stabilityCheck]);\n    var selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n    React.useDebugValue(selectedState);\n    return selectedState;\n  };\n  Object.assign(useSelector2, {\n    withTypes: function withTypes() {\n      return useSelector2;\n    }\n  });\n  return useSelector2;\n}\nvar useSelector = /* @__PURE__ */createSelectorHook();\n\n// src/utils/react-is.ts\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\nvar REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\nvar REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\nvar REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\nvar REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\nvar REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\nvar REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\nvar REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nfunction isValidElementType(type) {\n  if (typeof type === \"string\" || typeof type === \"function\") {\n    return true;\n  }\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE) {\n    return true;\n  }\n  if (typeof type === \"object\" && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||\n    // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction typeOf(object) {\n  if (typeof object === \"object\" && object !== null) {\n    var $$typeof = object.$$typeof;\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        {\n          var type = object.type;\n          switch (type) {\n            case REACT_FRAGMENT_TYPE:\n            case REACT_PROFILER_TYPE:\n            case REACT_STRICT_MODE_TYPE:\n            case REACT_SUSPENSE_TYPE:\n            case REACT_SUSPENSE_LIST_TYPE:\n              return type;\n            default:\n              {\n                var $$typeofType = type && type.$$typeof;\n                switch ($$typeofType) {\n                  case REACT_SERVER_CONTEXT_TYPE:\n                  case REACT_CONTEXT_TYPE:\n                  case REACT_FORWARD_REF_TYPE:\n                  case REACT_LAZY_TYPE:\n                  case REACT_MEMO_TYPE:\n                  case REACT_PROVIDER_TYPE:\n                    return $$typeofType;\n                  default:\n                    return $$typeof;\n                }\n              }\n          }\n        }\n      case REACT_PORTAL_TYPE:\n        {\n          return $$typeof;\n        }\n    }\n  }\n  return void 0;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\n\n// src/utils/warning.ts\nfunction warning(message) {\n  if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(message);\n  }\n  try {\n    throw new Error(message);\n  } catch (e) {}\n}\n\n// src/connect/verifySubselectors.ts\nfunction verify(selector, methodName) {\n  if (!selector) {\n    throw new Error(\"Unexpected value for \".concat(methodName, \" in connect.\"));\n  } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n    if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n      warning(\"The selector for \".concat(methodName, \" of connect did not specify a value for dependsOnOwnProps.\"));\n    }\n  }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n  verify(mapStateToProps, \"mapStateToProps\");\n  verify(mapDispatchToProps, \"mapDispatchToProps\");\n  verify(mergeProps, \"mergeProps\");\n}\n\n// src/connect/selectorFactory.ts\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref2) {\n  var areStatesEqual = _ref2.areStatesEqual,\n    areOwnPropsEqual = _ref2.areOwnPropsEqual,\n    areStatePropsEqual = _ref2.areStatePropsEqual;\n  var hasRunAtLeastOnce = false;\n  var state;\n  var ownProps;\n  var stateProps;\n  var dispatchProps;\n  var mergedProps;\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewState() {\n    var nextStateProps = mapStateToProps(state, ownProps);\n    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    var stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n    if (propsChanged) return handleNewProps();\n    if (stateChanged) return handleNewState();\n    return mergedProps;\n  }\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n}\nfunction finalPropsSelectorFactory(dispatch, _ref3) {\n  var initMapStateToProps = _ref3.initMapStateToProps,\n    initMapDispatchToProps = _ref3.initMapDispatchToProps,\n    initMergeProps = _ref3.initMergeProps,\n    options = _objectWithoutProperties(_ref3, _excluded);\n  var mapStateToProps = initMapStateToProps(dispatch, options);\n  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  var mergeProps = initMergeProps(dispatch, options);\n  if (process.env.NODE_ENV !== \"production\") {\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n  }\n  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n\n// src/utils/bindActionCreators.ts\nfunction bindActionCreators(actionCreators, dispatch) {\n  var boundActionCreators = {};\n  var _loop = function _loop() {\n    var actionCreator = actionCreators[key];\n    if (typeof actionCreator === \"function\") {\n      boundActionCreators[key] = function () {\n        return dispatch(actionCreator.apply(void 0, arguments));\n      };\n    }\n  };\n  for (var key in actionCreators) {\n    _loop();\n  }\n  return boundActionCreators;\n}\n\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n  if (typeof obj !== \"object\" || obj === null) return false;\n  var proto = Object.getPrototypeOf(obj);\n  if (proto === null) return true;\n  var baseProto = proto;\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto);\n  }\n  return proto === baseProto;\n}\n\n// src/utils/verifyPlainObject.ts\nfunction verifyPlainObject(value, displayName, methodName) {\n  if (!isPlainObject(value)) {\n    warning(\"\".concat(methodName, \"() in \").concat(displayName, \" must return a plain object. Instead received \").concat(value, \".\"));\n  }\n}\n\n// src/connect/wrapMapToProps.ts\nfunction wrapMapToPropsConstant(getConstant) {\n  return function initConstantSelector(dispatch) {\n    var constant = getConstant(dispatch);\n    function constantSelector() {\n      return constant;\n    }\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n}\nfunction getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, _ref4) {\n    var displayName = _ref4.displayName;\n    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n    };\n    proxy.dependsOnOwnProps = true;\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      var props = proxy(stateOrDispatch, ownProps);\n      if (typeof props === \"function\") {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n      if (process.env.NODE_ENV !== \"production\") verifyPlainObject(props, displayName, methodName);\n      return props;\n    };\n    return proxy;\n  };\n}\n\n// src/connect/invalidArgFactory.ts\nfunction createInvalidArgFactory(arg, name) {\n  return function (dispatch, options) {\n    throw new Error(\"Invalid value of type \".concat(typeof arg, \" for \").concat(name, \" argument when connecting component \").concat(options.wrappedComponentName, \".\"));\n  };\n}\n\n// src/connect/mapDispatchToProps.ts\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n  return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? wrapMapToPropsConstant(function (dispatch) {\n    return (\n      // @ts-ignore\n      bindActionCreators(mapDispatchToProps, dispatch)\n    );\n  }) : !mapDispatchToProps ? wrapMapToPropsConstant(function (dispatch) {\n    return {\n      dispatch: dispatch\n    };\n  }) : typeof mapDispatchToProps === \"function\" ?\n  // @ts-ignore\n  wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\") : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n}\n\n// src/connect/mapStateToProps.ts\nfunction mapStateToPropsFactory(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(function () {\n    return {};\n  }) : typeof mapStateToProps === \"function\" ?\n  // @ts-ignore\n  wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\") : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n}\n\n// src/connect/mergeProps.ts\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  return _objectSpread(_objectSpread(_objectSpread({}, ownProps), stateProps), dispatchProps);\n}\nfunction wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, _ref5) {\n    var displayName = _ref5.displayName,\n      areMergedPropsEqual = _ref5.areMergedPropsEqual;\n    var hasRunOnce = false;\n    var mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (process.env.NODE_ENV !== \"production\") verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n      }\n      return mergedProps;\n    };\n  };\n}\nfunction mergePropsFactory(mergeProps) {\n  return !mergeProps ? function () {\n    return defaultMergeProps;\n  } : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n}\n\n// src/utils/batch.ts\nfunction defaultNoopBatch(callback) {\n  callback();\n}\n\n// src/utils/Subscription.ts\nfunction createListenerCollection() {\n  var first = null;\n  var last = null;\n  return {\n    clear: function clear() {\n      first = null;\n      last = null;\n    },\n    notify: function notify() {\n      defaultNoopBatch(function () {\n        var listener = first;\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n    get: function get() {\n      var listeners = [];\n      var listener = first;\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n      return listeners;\n    },\n    subscribe: function subscribe(callback) {\n      var isSubscribed = true;\n      var listener = last = {\n        callback: callback,\n        next: null,\n        prev: last\n      };\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n  };\n}\nvar nullListeners = {\n  notify: function notify() {},\n  get: function get() {\n    return [];\n  }\n};\nfunction createSubscription(store, parentSub) {\n  var unsubscribe;\n  var listeners = nullListeners;\n  var subscriptionsAmount = 0;\n  var selfSubscribed = false;\n  function addNestedSub(listener) {\n    trySubscribe();\n    var cleanupListener = listeners.subscribe(listener);\n    var removed = false;\n    return function () {\n      if (!removed) {\n        removed = true;\n        cleanupListener();\n        tryUnsubscribe();\n      }\n    };\n  }\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n  function isSubscribed() {\n    return selfSubscribed;\n  }\n  function trySubscribe() {\n    subscriptionsAmount++;\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n  function tryUnsubscribe() {\n    subscriptionsAmount--;\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe();\n      unsubscribe = void 0;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true;\n      trySubscribe();\n    }\n  }\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false;\n      tryUnsubscribe();\n    }\n  }\n  var subscription = {\n    addNestedSub: addNestedSub,\n    notifyNestedSubs: notifyNestedSubs,\n    handleChangeWrapper: handleChangeWrapper,\n    isSubscribed: isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: function getListeners() {\n      return listeners;\n    }\n  };\n  return subscription;\n}\n\n// src/utils/useIsomorphicLayoutEffect.ts\nvar canUseDOM = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nvar useIsomorphicLayoutEffect = canUseDOM ? React.useLayoutEffect : React.useEffect;\n\n// src/utils/shallowEqual.ts\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) return true;\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n  for (var i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// src/utils/hoistStatics.ts\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  $$typeof: true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  $$typeof: true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = (_TYPE_STATICS = {}, _defineProperty(_TYPE_STATICS, ForwardRef, FORWARD_REF_STATICS), _defineProperty(_TYPE_STATICS, Memo, MEMO_STATICS), _TYPE_STATICS);\nfunction getStatics(component) {\n  if (isMemo(component)) {\n    return MEMO_STATICS;\n  }\n  return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n  if (typeof sourceComponent !== \"string\") {\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent);\n      }\n    }\n    var keys = getOwnPropertyNames(sourceComponent);\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n        try {\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n  return targetComponent;\n}\n\n// src/components/connect.tsx\nvar useSyncExternalStore = notInitialized;\nvar initializeConnect = function initializeConnect(fn) {\n  useSyncExternalStore = fn;\n};\nvar NO_SUBSCRIPTION_ARRAY = [null, null];\nvar stringifyComponent = function stringifyComponent(Comp) {\n  try {\n    return JSON.stringify(Comp);\n  } catch (err) {\n    return String(Comp);\n  }\n};\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n  useIsomorphicLayoutEffect(function () {\n    return effectFunc.apply(void 0, _toConsumableArray(effectArgs));\n  }, dependencies);\n}\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n  lastWrapperProps.current = wrapperProps;\n  renderIsScheduled.current = false;\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null;\n    notifyNestedSubs();\n  }\n}\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n  if (!shouldHandleStateChanges) return function () {};\n  var didUnsubscribe = false;\n  var lastThrownError = null;\n  var checkForUpdates = function checkForUpdates() {\n    if (didUnsubscribe || !isMounted.current) {\n      return;\n    }\n    var latestStoreState = store.getState();\n    var newChildProps, error;\n    try {\n      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n    } catch (e) {\n      error = e;\n      lastThrownError = e;\n    }\n    if (!error) {\n      lastThrownError = null;\n    }\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs();\n      }\n    } else {\n      lastChildProps.current = newChildProps;\n      childPropsFromStoreUpdate.current = newChildProps;\n      renderIsScheduled.current = true;\n      additionalSubscribeListener();\n    }\n  };\n  subscription.onStateChange = checkForUpdates;\n  subscription.trySubscribe();\n  checkForUpdates();\n  var unsubscribeWrapper = function unsubscribeWrapper() {\n    didUnsubscribe = true;\n    subscription.tryUnsubscribe();\n    subscription.onStateChange = null;\n    if (lastThrownError) {\n      throw lastThrownError;\n    }\n  };\n  return unsubscribeWrapper;\n}\nfunction strictEqual(a, b) {\n  return a === b;\n}\nvar hasWarnedAboutDeprecatedPureOption = false;\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps) {\n  var _ref6 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    pure = _ref6.pure,\n    _ref6$areStatesEqual = _ref6.areStatesEqual,\n    areStatesEqual = _ref6$areStatesEqual === void 0 ? strictEqual : _ref6$areStatesEqual,\n    _ref6$areOwnPropsEqua = _ref6.areOwnPropsEqual,\n    areOwnPropsEqual = _ref6$areOwnPropsEqua === void 0 ? shallowEqual : _ref6$areOwnPropsEqua,\n    _ref6$areStatePropsEq = _ref6.areStatePropsEqual,\n    areStatePropsEqual = _ref6$areStatePropsEq === void 0 ? shallowEqual : _ref6$areStatePropsEq,\n    _ref6$areMergedPropsE = _ref6.areMergedPropsEqual,\n    areMergedPropsEqual = _ref6$areMergedPropsE === void 0 ? shallowEqual : _ref6$areMergedPropsE,\n    _ref6$forwardRef = _ref6.forwardRef,\n    forwardRef = _ref6$forwardRef === void 0 ? false : _ref6$forwardRef,\n    _ref6$context = _ref6.context,\n    context = _ref6$context === void 0 ? ReactReduxContext : _ref6$context;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n      hasWarnedAboutDeprecatedPureOption = true;\n      warning('The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component');\n    }\n  }\n  var Context = context;\n  var initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n  var initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n  var initMergeProps = mergePropsFactory(mergeProps);\n  var shouldHandleStateChanges = Boolean(mapStateToProps);\n  var wrapWithConnect = function wrapWithConnect(WrappedComponent) {\n    if (process.env.NODE_ENV !== \"production\") {\n      var isValid = /* @__PURE__ */isValidElementType(WrappedComponent);\n      if (!isValid) throw new Error(\"You must pass a component to the function returned by connect. Instead received \".concat(stringifyComponent(WrappedComponent)));\n    }\n    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n    var displayName = \"Connect(\".concat(wrappedComponentName, \")\");\n    var selectorFactoryOptions = {\n      shouldHandleStateChanges: shouldHandleStateChanges,\n      displayName: displayName,\n      wrappedComponentName: wrappedComponentName,\n      WrappedComponent: WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps: initMapStateToProps,\n      // @ts-ignore\n      initMapDispatchToProps: initMapDispatchToProps,\n      initMergeProps: initMergeProps,\n      areStatesEqual: areStatesEqual,\n      areStatePropsEqual: areStatePropsEqual,\n      areOwnPropsEqual: areOwnPropsEqual,\n      areMergedPropsEqual: areMergedPropsEqual\n    };\n    function ConnectFunction(props) {\n      var _React$useMemo = React.useMemo(function () {\n          var reactReduxForwardedRef2 = props.reactReduxForwardedRef,\n            wrapperProps2 = _objectWithoutProperties(props, _excluded2);\n          return [props.context, reactReduxForwardedRef2, wrapperProps2];\n        }, [props]),\n        _React$useMemo2 = _slicedToArray(_React$useMemo, 3),\n        propsContext = _React$useMemo2[0],\n        reactReduxForwardedRef = _React$useMemo2[1],\n        wrapperProps = _React$useMemo2[2];\n      var ContextToUse = React.useMemo(function () {\n        var ResultContext = Context;\n        if (propsContext !== null && propsContext !== void 0 && propsContext.Consumer) {\n          if (process.env.NODE_ENV !== \"production\") {\n            var _isValid = /* @__PURE__ */isContextConsumer(\n            // @ts-ignore\n            /* @__PURE__ */\n            React.createElement(propsContext.Consumer, null));\n            if (!_isValid) {\n              throw new Error(\"You must pass a valid React context consumer as `props.context`\");\n            }\n            ResultContext = propsContext;\n          }\n        }\n        return ResultContext;\n      }, [propsContext, Context]);\n      var contextValue = React.useContext(ContextToUse);\n      var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n      var didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n      if (process.env.NODE_ENV !== \"production\" && !didStoreComeFromProps && !didStoreComeFromContext) {\n        throw new Error(\"Could not find \\\"store\\\" in the context of \\\"\".concat(displayName, \"\\\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to \").concat(displayName, \" in connect options.\"));\n      }\n      var store = didStoreComeFromProps ? props.store : contextValue.store;\n      var getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n      var childPropsSelector = React.useMemo(function () {\n        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n      }, [store]);\n      var _React$useMemo3 = React.useMemo(function () {\n          if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n          var subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);\n          var notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n          return [subscription2, notifyNestedSubs2];\n        }, [store, didStoreComeFromProps, contextValue]),\n        _React$useMemo4 = _slicedToArray(_React$useMemo3, 2),\n        subscription = _React$useMemo4[0],\n        notifyNestedSubs = _React$useMemo4[1];\n      var overriddenContextValue = React.useMemo(function () {\n        if (didStoreComeFromProps) {\n          return contextValue;\n        }\n        return _objectSpread(_objectSpread({}, contextValue), {}, {\n          subscription: subscription\n        });\n      }, [didStoreComeFromProps, contextValue, subscription]);\n      var lastChildProps = React.useRef();\n      var lastWrapperProps = React.useRef(wrapperProps);\n      var childPropsFromStoreUpdate = React.useRef();\n      var renderIsScheduled = React.useRef(false);\n      var isProcessingDispatch = React.useRef(false);\n      var isMounted = React.useRef(false);\n      var latestSubscriptionCallbackError = React.useRef();\n      useIsomorphicLayoutEffect(function () {\n        isMounted.current = true;\n        return function () {\n          isMounted.current = false;\n        };\n      }, []);\n      var actualChildPropsSelector = React.useMemo(function () {\n        var selector = function selector() {\n          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n            return childPropsFromStoreUpdate.current;\n          }\n          return childPropsSelector(store.getState(), wrapperProps);\n        };\n        return selector;\n      }, [store, wrapperProps]);\n      var subscribeForReact = React.useMemo(function () {\n        var subscribe = function subscribe(reactListener) {\n          if (!subscription) {\n            return function () {};\n          }\n          return subscribeUpdates(shouldHandleStateChanges, store, subscription,\n          // @ts-ignore\n          childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n        };\n        return subscribe;\n      }, [subscription]);\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs]);\n      var actualChildProps;\n      try {\n        actualChildProps = useSyncExternalStore(\n        // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n        subscribeForReact,\n        // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n        // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n        actualChildPropsSelector, getServerState ? function () {\n          return childPropsSelector(getServerState(), wrapperProps);\n        } : actualChildPropsSelector);\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          ;\n          err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n        }\n        throw err;\n      }\n      useIsomorphicLayoutEffect(function () {\n        latestSubscriptionCallbackError.current = void 0;\n        childPropsFromStoreUpdate.current = void 0;\n        lastChildProps.current = actualChildProps;\n      });\n      var renderedWrappedComponent = React.useMemo(function () {\n        return (\n          // @ts-ignore\n          /* @__PURE__ */\n          React.createElement(WrappedComponent, _objectSpread(_objectSpread({}, actualChildProps), {}, {\n            ref: reactReduxForwardedRef\n          }))\n        );\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);\n      var renderedChild = React.useMemo(function () {\n        if (shouldHandleStateChanges) {\n          return /* @__PURE__ */React.createElement(ContextToUse.Provider, {\n            value: overriddenContextValue\n          }, renderedWrappedComponent);\n        }\n        return renderedWrappedComponent;\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\n      return renderedChild;\n    }\n    var _Connect = React.memo(ConnectFunction);\n    var Connect = _Connect;\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = ConnectFunction.displayName = displayName;\n    if (forwardRef) {\n      var _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {\n        return /* @__PURE__ */React.createElement(Connect, _objectSpread(_objectSpread({}, props), {}, {\n          reactReduxForwardedRef: ref\n        }));\n      });\n      var forwarded = _forwarded;\n      forwarded.displayName = displayName;\n      forwarded.WrappedComponent = WrappedComponent;\n      return /* @__PURE__ */hoistNonReactStatics(forwarded, WrappedComponent);\n    }\n    return /* @__PURE__ */hoistNonReactStatics(Connect, WrappedComponent);\n  };\n  return wrapWithConnect;\n}\nvar connect_default = connect;\n\n// src/components/Provider.tsx\nfunction Provider(_ref7) {\n  var store = _ref7.store,\n    context = _ref7.context,\n    children = _ref7.children,\n    serverState = _ref7.serverState,\n    _ref7$stabilityCheck = _ref7.stabilityCheck,\n    stabilityCheck = _ref7$stabilityCheck === void 0 ? \"once\" : _ref7$stabilityCheck,\n    _ref7$identityFunctio = _ref7.identityFunctionCheck,\n    identityFunctionCheck = _ref7$identityFunctio === void 0 ? \"once\" : _ref7$identityFunctio;\n  var contextValue = React.useMemo(function () {\n    var subscription = createSubscription(store);\n    return {\n      store: store,\n      subscription: subscription,\n      getServerState: serverState ? function () {\n        return serverState;\n      } : void 0,\n      stabilityCheck: stabilityCheck,\n      identityFunctionCheck: identityFunctionCheck\n    };\n  }, [store, serverState, stabilityCheck, identityFunctionCheck]);\n  var previousState = React.useMemo(function () {\n    return store.getState();\n  }, [store]);\n  useIsomorphicLayoutEffect(function () {\n    var subscription = contextValue.subscription;\n    subscription.onStateChange = subscription.notifyNestedSubs;\n    subscription.trySubscribe();\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs();\n    }\n    return function () {\n      subscription.tryUnsubscribe();\n      subscription.onStateChange = void 0;\n    };\n  }, [contextValue, previousState]);\n  var Context = context || ReactReduxContext;\n  return /* @__PURE__ */React.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\nvar Provider_default = Provider;\n\n// src/hooks/useStore.ts\nfunction createStoreHook() {\n  var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  var useReduxContext2 = context === ReactReduxContext ? useReduxContext :\n  // @ts-ignore\n  createReduxContextHook(context);\n  var useStore2 = function useStore2() {\n    var _useReduxContext2 = useReduxContext2(),\n      store = _useReduxContext2.store;\n    return store;\n  };\n  Object.assign(useStore2, {\n    withTypes: function withTypes() {\n      return useStore2;\n    }\n  });\n  return useStore2;\n}\nvar useStore = /* @__PURE__ */createStoreHook();\n\n// src/hooks/useDispatch.ts\nfunction createDispatchHook() {\n  var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  var useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n  var useDispatch2 = function useDispatch2() {\n    var store = useStore2();\n    return store.dispatch;\n  };\n  Object.assign(useDispatch2, {\n    withTypes: function withTypes() {\n      return useDispatch2;\n    }\n  });\n  return useDispatch2;\n}\nvar useDispatch = /* @__PURE__ */createDispatchHook();\n\n// src/exports.ts\nvar batch = defaultNoopBatch;\n\n// src/index.ts\ninitializeUseSelector(useSyncExternalStoreWithSelector2);\ninitializeConnect(React2.useSyncExternalStore);\nexport { Provider_default as Provider, ReactReduxContext, batch, connect_default as connect, createDispatchHook, createSelectorHook, createStoreHook, shallowEqual, useDispatch, useSelector, useStore };","map":{"version":3,"names":["React2","useSyncExternalStoreWithSelector","useSyncExternalStoreWithSelector2","ReactOriginal","React","ContextKey","Symbol","for","gT","globalThis","getContext","_gT$ContextKey","createContext","contextMap","Map","realContext","get","process","env","NODE_ENV","displayName","set","ReactReduxContext","notInitialized","Error","createReduxContextHook","context","arguments","length","undefined","useReduxContext2","contextValue","useContext","useReduxContext","initializeUseSelector","fn","refEquality","a","b","createSelectorHook","useSelector2","selector","equalityFnOrOptions","_ref","equalityFn","_ref$equalityFn","_ref$devModeChecks","devModeChecks","_useReduxContext","store","subscription","getServerState","stabilityCheck","identityFunctionCheck","firstRun","useRef","wrappedSelector","useCallback","_defineProperty","name","state","selected","_stabilityCheck$ident","_objectSpread","finalIdentityFunctionCheck","finalStabilityCheck","current","toCompare","stack","e","console","warn","selected2","selectedState","addNestedSub","getState","useDebugValue","Object","assign","withTypes","useSelector","REACT_ELEMENT_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_PROVIDER_TYPE","REACT_CONTEXT_TYPE","REACT_SERVER_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_OFFSCREEN_TYPE","REACT_CLIENT_REFERENCE","ForwardRef","Memo","isValidElementType","type","$$typeof","getModuleId","typeOf","object","$$typeofType","isContextConsumer","isMemo","warning","message","error","verify","methodName","concat","prototype","hasOwnProperty","call","verifySubselectors","mapStateToProps","mapDispatchToProps","mergeProps","pureFinalPropsSelectorFactory","dispatch","_ref2","areStatesEqual","areOwnPropsEqual","areStatePropsEqual","hasRunAtLeastOnce","ownProps","stateProps","dispatchProps","mergedProps","handleFirstCall","firstState","firstOwnProps","handleNewPropsAndNewState","dependsOnOwnProps","handleNewProps","handleNewState","nextStateProps","statePropsChanged","handleSubsequentCalls","nextState","nextOwnProps","propsChanged","stateChanged","pureFinalPropsSelector","finalPropsSelectorFactory","_ref3","initMapStateToProps","initMapDispatchToProps","initMergeProps","options","_objectWithoutProperties","_excluded","bindActionCreators","actionCreators","boundActionCreators","_loop","actionCreator","key","apply","isPlainObject","obj","proto","getPrototypeOf","baseProto","verifyPlainObject","value","wrapMapToPropsConstant","getConstant","initConstantSelector","constant","constantSelector","getDependsOnOwnProps","mapToProps","Boolean","wrapMapToPropsFunc","initProxySelector","_ref4","proxy","mapToPropsProxy","stateOrDispatch","detectFactoryAndVerify","props","createInvalidArgFactory","arg","wrappedComponentName","mapDispatchToPropsFactory","mapStateToPropsFactory","defaultMergeProps","wrapMergePropsFunc","initMergePropsProxy","_ref5","areMergedPropsEqual","hasRunOnce","mergePropsProxy","nextMergedProps","mergePropsFactory","defaultNoopBatch","callback","createListenerCollection","first","last","clear","notify","listener","next","listeners","push","subscribe","isSubscribed","prev","unsubscribe","nullListeners","createSubscription","parentSub","subscriptionsAmount","selfSubscribed","trySubscribe","cleanupListener","removed","tryUnsubscribe","notifyNestedSubs","handleChangeWrapper","onStateChange","trySubscribeSelf","tryUnsubscribeSelf","getListeners","canUseDOM","window","document","createElement","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","is","x","y","shallowEqual","objA","objB","keysA","keys","keysB","i","REACT_STATICS","childContextTypes","contextType","contextTypes","defaultProps","getDefaultProps","getDerivedStateFromError","getDerivedStateFromProps","mixins","propTypes","KNOWN_STATICS","caller","callee","arity","FORWARD_REF_STATICS","render","MEMO_STATICS","compare","TYPE_STATICS","_TYPE_STATICS","getStatics","component","defineProperty","getOwnPropertyNames","getOwnPropertySymbols","getOwnPropertyDescriptor","objectPrototype","hoistNonReactStatics","targetComponent","sourceComponent","inheritedComponent","targetStatics","sourceStatics","descriptor","useSyncExternalStore","initializeConnect","NO_SUBSCRIPTION_ARRAY","stringifyComponent","Comp","JSON","stringify","err","String","useIsomorphicLayoutEffectWithArgs","effectFunc","effectArgs","dependencies","_toConsumableArray","captureWrapperProps","lastWrapperProps","lastChildProps","renderIsScheduled","wrapperProps","childPropsFromStoreUpdate","subscribeUpdates","shouldHandleStateChanges","childPropsSelector","isMounted","additionalSubscribeListener","didUnsubscribe","lastThrownError","checkForUpdates","latestStoreState","newChildProps","unsubscribeWrapper","strictEqual","hasWarnedAboutDeprecatedPureOption","connect","_ref6","pure","_ref6$areStatesEqual","_ref6$areOwnPropsEqua","_ref6$areStatePropsEq","_ref6$areMergedPropsE","_ref6$forwardRef","forwardRef","_ref6$context","Context","wrapWithConnect","WrappedComponent","isValid","selectorFactoryOptions","ConnectFunction","_React$useMemo","useMemo","reactReduxForwardedRef2","reactReduxForwardedRef","wrapperProps2","_excluded2","_React$useMemo2","_slicedToArray","propsContext","ContextToUse","ResultContext","Consumer","didStoreComeFromProps","didStoreComeFromContext","_React$useMemo3","subscription2","notifyNestedSubs2","bind","_React$useMemo4","overriddenContextValue","isProcessingDispatch","latestSubscriptionCallbackError","actualChildPropsSelector","subscribeForReact","reactListener","actualChildProps","renderedWrappedComponent","ref","renderedChild","Provider","_Connect","memo","Connect","_forwarded","forwardConnectRef","forwarded","connect_default","_ref7","children","serverState","_ref7$stabilityCheck","_ref7$identityFunctio","previousState","Provider_default","createStoreHook","useStore2","_useReduxContext2","useStore","createDispatchHook","useDispatch2","useDispatch","batch"],"sources":["D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\index.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\utils\\react.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\components\\Context.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\utils\\useSyncExternalStore.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\hooks\\useReduxContext.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\hooks\\useSelector.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\utils\\react-is.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\utils\\warning.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\connect\\verifySubselectors.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\connect\\selectorFactory.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\utils\\bindActionCreators.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\utils\\isPlainObject.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\utils\\verifyPlainObject.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\connect\\wrapMapToProps.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\connect\\invalidArgFactory.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\connect\\mapDispatchToProps.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\connect\\mapStateToProps.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\connect\\mergeProps.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\utils\\batch.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\utils\\Subscription.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\utils\\useIsomorphicLayoutEffect.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\utils\\shallowEqual.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\utils\\hoistStatics.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\components\\connect.tsx","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\components\\Provider.tsx","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\hooks\\useStore.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\hooks\\useDispatch.ts","D:\\TODO_new\\frontend\\node_modules\\react-redux\\src\\exports.ts"],"sourcesContent":["// The primary entry point assumes we are working with React 18, and thus have\n// useSyncExternalStore available. We can import that directly from React itself.\n// The useSyncExternalStoreWithSelector has to be imported, but we can use the\n// non-shim version. This shaves off the byte size of the shim.\n\nimport * as React from 'react'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector.js'\n\nimport { initializeUseSelector } from './hooks/useSelector'\nimport { initializeConnect } from './components/connect'\n\ninitializeUseSelector(useSyncExternalStoreWithSelector)\ninitializeConnect(React.useSyncExternalStore)\n\nexport * from './exports'\n","import * as ReactOriginal from 'react'\nimport type * as ReactNamespace from 'react'\n\nexport const React: typeof ReactNamespace =\n  // prettier-ignore\n  // @ts-ignore\n  'default' in ReactOriginal ? ReactOriginal['default'] : ReactOriginal as any\n","import type { Context } from 'react'\nimport { React } from '../utils/react'\nimport type { Action, Store, UnknownAction } from 'redux'\nimport type { Subscription } from '../utils/Subscription'\nimport type { ProviderProps } from './Provider'\n\nexport interface ReactReduxContextValue<\n  SS = any,\n  A extends Action<string> = UnknownAction\n> extends Pick<ProviderProps, 'stabilityCheck' | 'identityFunctionCheck'> {\n  store: Store<SS, A>\n  subscription: Subscription\n  getServerState?: () => SS\n}\n\nconst ContextKey = Symbol.for(`react-redux-context`)\nconst gT: {\n  [ContextKey]?: Map<\n    typeof React.createContext,\n    Context<ReactReduxContextValue | null>\n  >\n} = (\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {}\n) as any\n\nfunction getContext(): Context<ReactReduxContextValue | null> {\n  if (!React.createContext) return {} as any\n\n  const contextMap = (gT[ContextKey] ??= new Map<\n    typeof React.createContext,\n    Context<ReactReduxContextValue | null>\n  >())\n  let realContext = contextMap.get(React.createContext)\n  if (!realContext) {\n    realContext = React.createContext<ReactReduxContextValue | null>(\n      null as any,\n    )\n    if (process.env.NODE_ENV !== 'production') {\n      realContext.displayName = 'ReactRedux'\n    }\n    contextMap.set(React.createContext, realContext)\n  }\n  return realContext\n}\n\nexport const ReactReduxContext = /*#__PURE__*/ getContext()\n\nexport type ReactReduxContextInstance = typeof ReactReduxContext\n\nexport default ReactReduxContext\n","import type { useSyncExternalStore } from 'use-sync-external-store'\nimport type { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector'\n\nexport const notInitialized = () => {\n  throw new Error('uSES not initialized!')\n}\n\nexport type uSES = typeof useSyncExternalStore\nexport type uSESWS = typeof useSyncExternalStoreWithSelector\n","import { React } from '../utils/react'\nimport { ReactReduxContext } from '../components/Context'\nimport type { ReactReduxContextValue } from '../components/Context'\n\n/**\n * Hook factory, which creates a `useReduxContext` hook bound to a given context. This is a low-level\n * hook that you should usually not need to call directly.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useReduxContext` hook bound to the specified context.\n */\nexport function createReduxContextHook(context = ReactReduxContext) {\n  return function useReduxContext(): ReactReduxContextValue {\n    const contextValue = React.useContext(context)\n\n    if (process.env.NODE_ENV !== 'production' && !contextValue) {\n      throw new Error(\n        'could not find react-redux context value; please ensure the component is wrapped in a <Provider>',\n      )\n    }\n\n    return contextValue!\n  }\n}\n\n/**\n * A hook to access the value of the `ReactReduxContext`. This is a low-level\n * hook that you should usually not need to call directly.\n *\n * @returns {any} the value of the `ReactReduxContext`\n *\n * @example\n *\n * import React from 'react'\n * import { useReduxContext } from 'react-redux'\n *\n * export const CounterComponent = () => {\n *   const { store } = useReduxContext()\n *   return <div>{store.getState()}</div>\n * }\n */\nexport const useReduxContext = /*#__PURE__*/ createReduxContextHook()\n","//import * as React from 'react'\nimport { React } from '../utils/react'\n\nimport type { ReactReduxContextValue } from '../components/Context'\nimport { ReactReduxContext } from '../components/Context'\nimport type { EqualityFn, NoInfer } from '../types'\nimport type { uSESWS } from '../utils/useSyncExternalStore'\nimport { notInitialized } from '../utils/useSyncExternalStore'\nimport {\n  createReduxContextHook,\n  useReduxContext as useDefaultReduxContext,\n} from './useReduxContext'\n\n/**\n * The frequency of development mode checks.\n *\n * @since 8.1.0\n * @internal\n */\nexport type DevModeCheckFrequency = 'never' | 'once' | 'always'\n\n/**\n * Represents the configuration for development mode checks.\n *\n * @since 9.0.0\n * @internal\n */\nexport interface DevModeChecks {\n  /**\n   * Overrides the global stability check for the selector.\n   * - `once` - Run only the first time the selector is called.\n   * - `always` - Run every time the selector is called.\n   * - `never` - Never run the stability check.\n   *\n   * @default 'once'\n   *\n   * @since 8.1.0\n   */\n  stabilityCheck: DevModeCheckFrequency\n\n  /**\n   * Overrides the global identity function check for the selector.\n   * - `once` - Run only the first time the selector is called.\n   * - `always` - Run every time the selector is called.\n   * - `never` - Never run the identity function check.\n   *\n   * **Note**: Previously referred to as `noopCheck`.\n   *\n   * @default 'once'\n   *\n   * @since 9.0.0\n   */\n  identityFunctionCheck: DevModeCheckFrequency\n}\n\nexport interface UseSelectorOptions<Selected = unknown> {\n  equalityFn?: EqualityFn<Selected>\n\n  /**\n   * `useSelector` performs additional checks in development mode to help\n   * identify and warn about potential issues in selector behavior. This\n   * option allows you to customize the behavior of these checks per selector.\n   *\n   * @since 9.0.0\n   */\n  devModeChecks?: Partial<DevModeChecks>\n}\n\n/**\n * Represents a custom hook that allows you to extract data from the\n * Redux store state, using a selector function. The selector function\n * takes the current state as an argument and returns a part of the state\n * or some derived data. The hook also supports an optional equality\n * function or options object to customize its behavior.\n *\n * @template StateType - The specific type of state this hook operates on.\n *\n * @public\n */\nexport interface UseSelector<StateType = unknown> {\n  /**\n   * A function that takes a selector function as its first argument.\n   * The selector function is responsible for selecting a part of\n   * the Redux store's state or computing derived data.\n   *\n   * @param selector - A function that receives the current state and returns a part of the state or some derived data.\n   * @param equalityFnOrOptions - An optional equality function or options object for customizing the behavior of the selector.\n   * @returns The selected part of the state or derived data.\n   *\n   * @template TState - The specific type of state this hook operates on.\n   * @template Selected - The type of the value that the selector function will return.\n   */\n  <TState extends StateType = StateType, Selected = unknown>(\n    selector: (state: TState) => Selected,\n    equalityFnOrOptions?: EqualityFn<Selected> | UseSelectorOptions<Selected>\n  ): Selected\n\n  /**\n   * Creates a \"pre-typed\" version of {@linkcode useSelector useSelector}\n   * where the `state` type is predefined.\n   *\n   * This allows you to set the `state` type once, eliminating the need to\n   * specify it with every {@linkcode useSelector useSelector} call.\n   *\n   * @returns A pre-typed `useSelector` with the state type already defined.\n   *\n   * @example\n   * ```ts\n   * export const useAppSelector = useSelector.withTypes<RootState>()\n   * ```\n   *\n   * @template OverrideStateType - The specific type of state this hook operates on.\n   *\n   * @since 9.1.0\n   */\n  withTypes: <\n    OverrideStateType extends StateType\n  >() => UseSelector<OverrideStateType>\n}\n\nlet useSyncExternalStoreWithSelector = notInitialized as uSESWS\nexport const initializeUseSelector = (fn: uSESWS) => {\n  useSyncExternalStoreWithSelector = fn\n}\n\nconst refEquality: EqualityFn<any> = (a, b) => a === b\n\n/**\n * Hook factory, which creates a `useSelector` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useSelector` hook bound to the specified context.\n */\nexport function createSelectorHook(\n  context: React.Context<ReactReduxContextValue<\n    any,\n    any\n  > | null> = ReactReduxContext,\n): UseSelector {\n  const useReduxContext =\n    context === ReactReduxContext\n      ? useDefaultReduxContext\n      : createReduxContextHook(context)\n\n  const useSelector = <TState, Selected extends unknown>(\n    selector: (state: TState) => Selected,\n    equalityFnOrOptions:\n      | EqualityFn<NoInfer<Selected>>\n      | UseSelectorOptions<NoInfer<Selected>> = {}\n  ): Selected => {\n    const { equalityFn = refEquality, devModeChecks = {} } =\n      typeof equalityFnOrOptions === 'function'\n        ? { equalityFn: equalityFnOrOptions }\n        : equalityFnOrOptions\n    if (process.env.NODE_ENV !== 'production') {\n      if (!selector) {\n        throw new Error(`You must pass a selector to useSelector`)\n      }\n      if (typeof selector !== 'function') {\n        throw new Error(`You must pass a function as a selector to useSelector`)\n      }\n      if (typeof equalityFn !== 'function') {\n        throw new Error(\n          `You must pass a function as an equality function to useSelector`,\n        )\n      }\n    }\n\n    const {\n      store,\n      subscription,\n      getServerState,\n      stabilityCheck,\n      identityFunctionCheck,\n    } = useReduxContext()\n\n    const firstRun = React.useRef(true)\n\n    const wrappedSelector = React.useCallback<typeof selector>(\n      {\n        [selector.name](state: TState) {\n          const selected = selector(state)\n          if (process.env.NODE_ENV !== 'production') {\n            const {\n              identityFunctionCheck: finalIdentityFunctionCheck,\n              stabilityCheck: finalStabilityCheck,\n            } = {\n              stabilityCheck,\n              identityFunctionCheck,\n              ...devModeChecks,\n            }\n            if (\n              finalStabilityCheck === 'always' ||\n              (finalStabilityCheck === 'once' && firstRun.current)\n            ) {\n              const toCompare = selector(state)\n              if (!equalityFn(selected, toCompare)) {\n                let stack: string | undefined = undefined\n                try {\n                  throw new Error()\n                } catch (e) {\n                  // eslint-disable-next-line no-extra-semi\n                  ;({ stack } = e as Error)\n                }\n                console.warn(\n                  'Selector ' +\n                    (selector.name || 'unknown') +\n                    ' returned a different result when called with the same parameters. This can lead to unnecessary rerenders.' +\n                    '\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization',\n                  {\n                    state,\n                    selected,\n                    selected2: toCompare,\n                    stack,\n                  },\n                )\n              }\n            }\n            if (\n              finalIdentityFunctionCheck === 'always' ||\n              (finalIdentityFunctionCheck === 'once' && firstRun.current)\n            ) {\n              // @ts-ignore\n              if (selected === state) {\n                let stack: string | undefined = undefined\n                try {\n                  throw new Error()\n                } catch (e) {\n                  // eslint-disable-next-line no-extra-semi\n                  ;({ stack } = e as Error)\n                }\n                console.warn(\n                  'Selector ' +\n                    (selector.name || 'unknown') +\n                    ' returned the root state when called. This can lead to unnecessary rerenders.' +\n                    '\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.',\n                  { stack },\n                )\n              }\n            }\n            if (firstRun.current) firstRun.current = false\n          }\n          return selected\n        },\n      }[selector.name],\n      [selector, stabilityCheck, devModeChecks.stabilityCheck],\n    )\n\n    const selectedState = useSyncExternalStoreWithSelector(\n      subscription.addNestedSub,\n      store.getState,\n      getServerState || store.getState,\n      wrappedSelector,\n      equalityFn,\n    )\n\n    React.useDebugValue(selectedState)\n\n    return selectedState\n  }\n\n  Object.assign(useSelector, {\n    withTypes: () => useSelector,\n  })\n\n  return useSelector as UseSelector\n}\n\n/**\n * A hook to access the redux store's state. This hook takes a selector function\n * as an argument. The selector is called with the store state.\n *\n * This hook takes an optional equality comparison function as the second parameter\n * that allows you to customize the way the selected state is compared to determine\n * whether the component needs to be re-rendered.\n *\n * @param {Function} selector the selector function\n * @param {Function=} equalityFn the function that will be used to determine equality\n *\n * @returns {any} the selected state\n *\n * @example\n *\n * import React from 'react'\n * import { useSelector } from 'react-redux'\n *\n * export const CounterComponent = () => {\n *   const counter = useSelector(state => state.counter)\n *   return <div>{counter}</div>\n * }\n */\nexport const useSelector = /*#__PURE__*/ createSelectorHook()\n","import type { ElementType, MemoExoticComponent, ReactElement } from 'react'\n\n// Directly ported from:\n// https://unpkg.com/browse/react-is@18.3.0-canary-ee68446ff-20231115/cjs/react-is.production.js\n// It's very possible this could change in the future, but given that\n// we only use these in `connect`, this is a low priority.\n\nconst REACT_ELEMENT_TYPE = Symbol.for('react.element')\nconst REACT_PORTAL_TYPE = Symbol.for('react.portal')\nconst REACT_FRAGMENT_TYPE = Symbol.for('react.fragment')\nconst REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode')\nconst REACT_PROFILER_TYPE = Symbol.for('react.profiler')\nconst REACT_PROVIDER_TYPE = Symbol.for('react.provider')\nconst REACT_CONTEXT_TYPE = Symbol.for('react.context')\nconst REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context')\nconst REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref')\nconst REACT_SUSPENSE_TYPE = Symbol.for('react.suspense')\nconst REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list')\nconst REACT_MEMO_TYPE = Symbol.for('react.memo')\nconst REACT_LAZY_TYPE = Symbol.for('react.lazy')\nconst REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen')\nconst REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference')\n\nexport const ForwardRef = REACT_FORWARD_REF_TYPE\nexport const Memo = REACT_MEMO_TYPE\n\nexport function isValidElementType(type: any): type is ElementType {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n  if (\n    type === REACT_FRAGMENT_TYPE ||\n    type === REACT_PROFILER_TYPE ||\n    type === REACT_STRICT_MODE_TYPE ||\n    type === REACT_SUSPENSE_TYPE ||\n    type === REACT_SUSPENSE_LIST_TYPE ||\n    type === REACT_OFFSCREEN_TYPE\n  ) {\n    return true\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (\n      type.$$typeof === REACT_LAZY_TYPE ||\n      type.$$typeof === REACT_MEMO_TYPE ||\n      type.$$typeof === REACT_PROVIDER_TYPE ||\n      type.$$typeof === REACT_CONTEXT_TYPE ||\n      type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      type.$$typeof === REACT_CLIENT_REFERENCE ||\n      type.getModuleId !== undefined\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\nfunction typeOf(object: any): symbol | undefined {\n  if (typeof object === 'object' && object !== null) {\n    const $$typeof = object.$$typeof\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE: {\n        const type = object.type\n\n        switch (type) {\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n          case REACT_SUSPENSE_LIST_TYPE:\n            return type\n\n          default: {\n            const $$typeofType = type && type.$$typeof\n\n            switch ($$typeofType) {\n              case REACT_SERVER_CONTEXT_TYPE:\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType\n\n              default:\n                return $$typeof\n            }\n          }\n        }\n      }\n\n      case REACT_PORTAL_TYPE: {\n        return $$typeof\n      }\n    }\n  }\n\n  return undefined\n}\n\nexport function isContextConsumer(object: any): object is ReactElement {\n  return typeOf(object) === REACT_CONTEXT_TYPE\n}\n\nexport function isMemo(object: any): object is MemoExoticComponent<any> {\n  return typeOf(object) === REACT_MEMO_TYPE\n}\n","/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nexport default function warning(message: string) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message)\n  }\n  /* eslint-enable no-console */\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message)\n    /* eslint-disable no-empty */\n  } catch (e) {}\n  /* eslint-enable no-empty */\n}\n","import warning from '../utils/warning'\n\nfunction verify(selector: unknown, methodName: string): void {\n  if (!selector) {\n    throw new Error(`Unexpected value for ${methodName} in connect.`)\n  } else if (\n    methodName === 'mapStateToProps' ||\n    methodName === 'mapDispatchToProps'\n  ) {\n    if (!Object.prototype.hasOwnProperty.call(selector, 'dependsOnOwnProps')) {\n      warning(\n        `The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`,\n      )\n    }\n  }\n}\n\nexport default function verifySubselectors(\n  mapStateToProps: unknown,\n  mapDispatchToProps: unknown,\n  mergeProps: unknown,\n): void {\n  verify(mapStateToProps, 'mapStateToProps')\n  verify(mapDispatchToProps, 'mapDispatchToProps')\n  verify(mergeProps, 'mergeProps')\n}\n","import type { Dispatch, Action } from 'redux'\nimport type { ComponentType } from 'react'\nimport verifySubselectors from './verifySubselectors'\nimport type { EqualityFn, ExtendedEqualityFn } from '../types'\n\nexport type SelectorFactory<S, TProps, TOwnProps, TFactoryOptions> = (\n  dispatch: Dispatch<Action<string>>,\n  factoryOptions: TFactoryOptions\n) => Selector<S, TProps, TOwnProps>\n\nexport type Selector<S, TProps, TOwnProps = null> = TOwnProps extends\n  | null\n  | undefined\n  ? (state: S) => TProps\n  : (state: S, ownProps: TOwnProps) => TProps\n\nexport type MapStateToProps<TStateProps, TOwnProps, State> = (\n  state: State,\n  ownProps: TOwnProps\n) => TStateProps\n\nexport type MapStateToPropsFactory<TStateProps, TOwnProps, State> = (\n  initialState: State,\n  ownProps: TOwnProps\n) => MapStateToProps<TStateProps, TOwnProps, State>\n\nexport type MapStateToPropsParam<TStateProps, TOwnProps, State> =\n  | MapStateToPropsFactory<TStateProps, TOwnProps, State>\n  | MapStateToProps<TStateProps, TOwnProps, State>\n  | null\n  | undefined\n\nexport type MapDispatchToPropsFunction<TDispatchProps, TOwnProps> = (\n  dispatch: Dispatch<Action<string>>,\n  ownProps: TOwnProps\n) => TDispatchProps\n\nexport type MapDispatchToProps<TDispatchProps, TOwnProps> =\n  | MapDispatchToPropsFunction<TDispatchProps, TOwnProps>\n  | TDispatchProps\n\nexport type MapDispatchToPropsFactory<TDispatchProps, TOwnProps> = (\n  dispatch: Dispatch<Action<string>>,\n  ownProps: TOwnProps\n) => MapDispatchToPropsFunction<TDispatchProps, TOwnProps>\n\nexport type MapDispatchToPropsParam<TDispatchProps, TOwnProps> =\n  | MapDispatchToPropsFactory<TDispatchProps, TOwnProps>\n  | MapDispatchToProps<TDispatchProps, TOwnProps>\n\nexport type MapDispatchToPropsNonObject<TDispatchProps, TOwnProps> =\n  | MapDispatchToPropsFactory<TDispatchProps, TOwnProps>\n  | MapDispatchToPropsFunction<TDispatchProps, TOwnProps>\n\nexport type MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps> = (\n  stateProps: TStateProps,\n  dispatchProps: TDispatchProps,\n  ownProps: TOwnProps\n) => TMergedProps\n\ninterface PureSelectorFactoryComparisonOptions<TStateProps, TOwnProps, State> {\n  readonly areStatesEqual: ExtendedEqualityFn<State, TOwnProps>\n  readonly areStatePropsEqual: EqualityFn<TStateProps>\n  readonly areOwnPropsEqual: EqualityFn<TOwnProps>\n}\n\nexport function pureFinalPropsSelectorFactory<\n  TStateProps,\n  TOwnProps,\n  TDispatchProps,\n  TMergedProps,\n  State\n>(\n  mapStateToProps: WrappedMapStateToProps<TStateProps, TOwnProps, State>,\n  mapDispatchToProps: WrappedMapDispatchToProps<TDispatchProps, TOwnProps>,\n  mergeProps: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,\n  dispatch: Dispatch<Action<string>>,\n  {\n    areStatesEqual,\n    areOwnPropsEqual,\n    areStatePropsEqual,\n  }: PureSelectorFactoryComparisonOptions<TStateProps, TOwnProps, State>,\n) {\n  let hasRunAtLeastOnce = false\n  let state: State\n  let ownProps: TOwnProps\n  let stateProps: TStateProps\n  let dispatchProps: TDispatchProps\n  let mergedProps: TMergedProps\n\n  function handleFirstCall(firstState: State, firstOwnProps: TOwnProps) {\n    state = firstState\n    ownProps = firstOwnProps\n    stateProps = mapStateToProps(state, ownProps)\n    dispatchProps = mapDispatchToProps(dispatch, ownProps)\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n    hasRunAtLeastOnce = true\n    return mergedProps\n  }\n\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps)\n\n    if (mapDispatchToProps.dependsOnOwnProps)\n      dispatchProps = mapDispatchToProps(dispatch, ownProps)\n\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n    return mergedProps\n  }\n\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps)\n      stateProps = mapStateToProps(state, ownProps)\n\n    if (mapDispatchToProps.dependsOnOwnProps)\n      dispatchProps = mapDispatchToProps(dispatch, ownProps)\n\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n    return mergedProps\n  }\n\n  function handleNewState() {\n    const nextStateProps = mapStateToProps(state, ownProps)\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps)\n    stateProps = nextStateProps\n\n    if (statePropsChanged)\n      mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n\n    return mergedProps\n  }\n\n  function handleSubsequentCalls(nextState: State, nextOwnProps: TOwnProps) {\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)\n    const stateChanged = !areStatesEqual(\n      nextState,\n      state,\n      nextOwnProps,\n      ownProps,\n    )\n    state = nextState\n    ownProps = nextOwnProps\n\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState()\n    if (propsChanged) return handleNewProps()\n    if (stateChanged) return handleNewState()\n    return mergedProps\n  }\n\n  return function pureFinalPropsSelector(\n    nextState: State,\n    nextOwnProps: TOwnProps,\n  ) {\n    return hasRunAtLeastOnce\n      ? handleSubsequentCalls(nextState, nextOwnProps)\n      : handleFirstCall(nextState, nextOwnProps)\n  }\n}\n\ninterface WrappedMapStateToProps<TStateProps, TOwnProps, State> {\n  (state: State, ownProps: TOwnProps): TStateProps\n  readonly dependsOnOwnProps: boolean\n}\n\ninterface WrappedMapDispatchToProps<TDispatchProps, TOwnProps> {\n  (dispatch: Dispatch<Action<string>>, ownProps: TOwnProps): TDispatchProps\n  readonly dependsOnOwnProps: boolean\n}\n\nexport interface InitOptions<TStateProps, TOwnProps, TMergedProps, State>\n  extends PureSelectorFactoryComparisonOptions<TStateProps, TOwnProps, State> {\n  readonly shouldHandleStateChanges: boolean\n  readonly displayName: string\n  readonly wrappedComponentName: string\n  readonly WrappedComponent: ComponentType<TOwnProps>\n  readonly areMergedPropsEqual: EqualityFn<TMergedProps>\n}\n\nexport interface SelectorFactoryOptions<\n  TStateProps,\n  TOwnProps,\n  TDispatchProps,\n  TMergedProps,\n  State\n> extends InitOptions<TStateProps, TOwnProps, TMergedProps, State> {\n  readonly initMapStateToProps: (\n    dispatch: Dispatch<Action<string>>,\n    options: InitOptions<TStateProps, TOwnProps, TMergedProps, State>\n  ) => WrappedMapStateToProps<TStateProps, TOwnProps, State>\n  readonly initMapDispatchToProps: (\n    dispatch: Dispatch<Action<string>>,\n    options: InitOptions<TStateProps, TOwnProps, TMergedProps, State>\n  ) => WrappedMapDispatchToProps<TDispatchProps, TOwnProps>\n  readonly initMergeProps: (\n    dispatch: Dispatch<Action<string>>,\n    options: InitOptions<TStateProps, TOwnProps, TMergedProps, State>\n  ) => MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>\n}\n\n// TODO: Add more comments\n\n// The selector returned by selectorFactory will memoize its results,\n// allowing connect's shouldComponentUpdate to return false if final\n// props have not changed.\n\nexport default function finalPropsSelectorFactory<\n  TStateProps,\n  TOwnProps,\n  TDispatchProps,\n  TMergedProps,\n  State\n>(\n  dispatch: Dispatch<Action<string>>,\n  {\n    initMapStateToProps,\n    initMapDispatchToProps,\n    initMergeProps,\n    ...options\n  }: SelectorFactoryOptions<\n    TStateProps,\n    TOwnProps,\n    TDispatchProps,\n    TMergedProps,\n    State\n  >,\n) {\n  const mapStateToProps = initMapStateToProps(dispatch, options)\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options)\n  const mergeProps = initMergeProps(dispatch, options)\n\n  if (process.env.NODE_ENV !== 'production') {\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps)\n  }\n\n  return pureFinalPropsSelectorFactory<\n    TStateProps,\n    TOwnProps,\n    TDispatchProps,\n    TMergedProps,\n    State\n  >(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options)\n}\n","import type { ActionCreatorsMapObject, Dispatch } from 'redux'\n\nexport default function bindActionCreators(\n  actionCreators: ActionCreatorsMapObject,\n  dispatch: Dispatch,\n): ActionCreatorsMapObject {\n  const boundActionCreators: ActionCreatorsMapObject = {}\n\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key]\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args))\n    }\n  }\n  return boundActionCreators\n}\n","/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\nexport default function isPlainObject(obj: unknown) {\n  if (typeof obj !== 'object' || obj === null) return false\n\n  const proto = Object.getPrototypeOf(obj)\n  if (proto === null) return true\n\n  let baseProto = proto\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto)\n  }\n\n  return proto === baseProto\n}\n","import isPlainObject from './isPlainObject'\nimport warning from './warning'\n\nexport default function verifyPlainObject(\n  value: unknown,\n  displayName: string,\n  methodName: string,\n) {\n  if (!isPlainObject(value)) {\n    warning(\n      `${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`,\n    )\n  }\n}\n","import type { ActionCreatorsMapObject, Dispatch, ActionCreator } from 'redux'\n\nimport type { FixTypeLater } from '../types'\nimport verifyPlainObject from '../utils/verifyPlainObject'\n\ntype AnyState = { [key: string]: any }\ntype StateOrDispatch<S extends AnyState = AnyState> = S | Dispatch\n\ntype AnyProps = { [key: string]: any }\n\nexport type MapToProps<P extends AnyProps = AnyProps> = {\n  // eslint-disable-next-line no-unused-vars\n  (stateOrDispatch: StateOrDispatch, ownProps?: P): FixTypeLater\n  dependsOnOwnProps?: boolean\n}\n\nexport function wrapMapToPropsConstant(\n  // * Note:\n  //  It seems that the dispatch argument\n  //  could be a dispatch function in some cases (ex: whenMapDispatchToPropsIsMissing)\n  //  and a state object in some others (ex: whenMapStateToPropsIsMissing)\n  // eslint-disable-next-line no-unused-vars\n  getConstant: (dispatch: Dispatch) =>\n    | {\n        dispatch?: Dispatch\n        dependsOnOwnProps?: boolean\n      }\n    | ActionCreatorsMapObject\n    | ActionCreator<any>,\n) {\n  return function initConstantSelector(dispatch: Dispatch) {\n    const constant = getConstant(dispatch)\n\n    function constantSelector() {\n      return constant\n    }\n    constantSelector.dependsOnOwnProps = false\n    return constantSelector\n  }\n}\n\n// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\n// whether mapToProps needs to be invoked when props have changed.\n//\n// A length of one signals that mapToProps does not depend on props from the parent component.\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\n// therefore not reporting its length accurately..\n// TODO Can this get pulled out so that we can subscribe directly to the store if we don't need ownProps?\nexport function getDependsOnOwnProps(mapToProps: MapToProps) {\n  return mapToProps.dependsOnOwnProps\n    ? Boolean(mapToProps.dependsOnOwnProps)\n    : mapToProps.length !== 1\n}\n\n// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\n// this function wraps mapToProps in a proxy function which does several things:\n//\n//  * Detects whether the mapToProps function being called depends on props, which\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\n//\n//  * On first call, handles mapToProps if returns another function, and treats that\n//    new function as the true mapToProps for subsequent calls.\n//\n//  * On first call, verifies the first result is a plain object, in order to warn\n//    the developer that their mapToProps function is not returning a valid result.\n//\nexport function wrapMapToPropsFunc<P extends AnyProps = AnyProps>(\n  mapToProps: MapToProps,\n  methodName: string,\n) {\n  return function initProxySelector(\n    dispatch: Dispatch,\n    { displayName }: { displayName: string },\n  ) {\n    const proxy = function mapToPropsProxy(\n      stateOrDispatch: StateOrDispatch,\n      ownProps?: P,\n    ): MapToProps {\n      return proxy.dependsOnOwnProps\n        ? proxy.mapToProps(stateOrDispatch, ownProps)\n        : proxy.mapToProps(stateOrDispatch, undefined)\n    }\n\n    // allow detectFactoryAndVerify to get ownProps\n    proxy.dependsOnOwnProps = true\n\n    proxy.mapToProps = function detectFactoryAndVerify(\n      stateOrDispatch: StateOrDispatch,\n      ownProps?: P,\n    ): MapToProps {\n      proxy.mapToProps = mapToProps\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)\n      let props = proxy(stateOrDispatch, ownProps)\n\n      if (typeof props === 'function') {\n        proxy.mapToProps = props\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)\n        props = proxy(stateOrDispatch, ownProps)\n      }\n\n      if (process.env.NODE_ENV !== 'production')\n        verifyPlainObject(props, displayName, methodName)\n\n      return props\n    }\n\n    return proxy\n  }\n}\n","import type { Action, Dispatch } from 'redux'\n\nexport function createInvalidArgFactory(arg: unknown, name: string) {\n  return (\n    dispatch: Dispatch<Action<string>>,\n    options: { readonly wrappedComponentName: string },\n  ) => {\n    throw new Error(\n      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${\n        options.wrappedComponentName\n      }.`,\n    )\n  }\n}\n","import type { Action, Dispatch } from 'redux'\nimport bindActionCreators from '../utils/bindActionCreators'\nimport { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'\nimport { createInvalidArgFactory } from './invalidArgFactory'\nimport type { MapDispatchToPropsParam } from './selectorFactory'\n\nexport function mapDispatchToPropsFactory<TDispatchProps, TOwnProps>(\n  mapDispatchToProps:\n    | MapDispatchToPropsParam<TDispatchProps, TOwnProps>\n    | undefined,\n) {\n  return mapDispatchToProps && typeof mapDispatchToProps === 'object'\n    ? wrapMapToPropsConstant((dispatch: Dispatch<Action<string>>) =>\n        // @ts-ignore\n        bindActionCreators(mapDispatchToProps, dispatch),\n      )\n    : !mapDispatchToProps\n    ? wrapMapToPropsConstant((dispatch: Dispatch<Action<string>>) => ({\n        dispatch,\n      }))\n    : typeof mapDispatchToProps === 'function'\n    ? // @ts-ignore\n      wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps')\n    : createInvalidArgFactory(mapDispatchToProps, 'mapDispatchToProps')\n}\n","import { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'\nimport { createInvalidArgFactory } from './invalidArgFactory'\nimport type { MapStateToPropsParam } from './selectorFactory'\n\nexport function mapStateToPropsFactory<TStateProps, TOwnProps, State>(\n  mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n) {\n  return !mapStateToProps\n    ? wrapMapToPropsConstant(() => ({}))\n    : typeof mapStateToProps === 'function'\n    ? // @ts-ignore\n      wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')\n    : createInvalidArgFactory(mapStateToProps, 'mapStateToProps')\n}\n","import type { Action, Dispatch } from 'redux'\nimport verifyPlainObject from '../utils/verifyPlainObject'\nimport { createInvalidArgFactory } from './invalidArgFactory'\nimport type { MergeProps } from './selectorFactory'\nimport type { EqualityFn } from '../types'\n\nexport function defaultMergeProps<\n  TStateProps,\n  TDispatchProps,\n  TOwnProps,\n  TMergedProps\n>(\n  stateProps: TStateProps,\n  dispatchProps: TDispatchProps,\n  ownProps: TOwnProps,\n): TMergedProps {\n  // @ts-ignore\n  return { ...ownProps, ...stateProps, ...dispatchProps }\n}\n\nexport function wrapMergePropsFunc<\n  TStateProps,\n  TDispatchProps,\n  TOwnProps,\n  TMergedProps\n>(\n  mergeProps: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,\n): (\n  dispatch: Dispatch<Action<string>>,\n  options: {\n    readonly displayName: string\n    readonly areMergedPropsEqual: EqualityFn<TMergedProps>\n  }\n) => MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps> {\n  return function initMergePropsProxy(\n    dispatch,\n    { displayName, areMergedPropsEqual },\n  ) {\n    let hasRunOnce = false\n    let mergedProps: TMergedProps\n\n    return function mergePropsProxy(\n      stateProps: TStateProps,\n      dispatchProps: TDispatchProps,\n      ownProps: TOwnProps,\n    ) {\n      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps))\n          mergedProps = nextMergedProps\n      } else {\n        hasRunOnce = true\n        mergedProps = nextMergedProps\n\n        if (process.env.NODE_ENV !== 'production')\n          verifyPlainObject(mergedProps, displayName, 'mergeProps')\n      }\n\n      return mergedProps\n    }\n  }\n}\n\nexport function mergePropsFactory<\n  TStateProps,\n  TDispatchProps,\n  TOwnProps,\n  TMergedProps\n>(\n  mergeProps?: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,\n) {\n  return !mergeProps\n    ? () => defaultMergeProps\n    : typeof mergeProps === 'function'\n    ? wrapMergePropsFunc(mergeProps)\n    : createInvalidArgFactory(mergeProps, 'mergeProps')\n}\n","// Default to a dummy \"batch\" implementation that just runs the callback\nexport function defaultNoopBatch(callback: () => void) {\n  callback()\n}\n","import { defaultNoopBatch as batch } from './batch'\n\n// encapsulates the subscription logic for connecting a component to the redux store, as\n// well as nesting subscriptions of descendant components, so that we can ensure the\n// ancestor components re-render before descendants\n\ntype VoidFunc = () => void\n\ntype Listener = {\n  callback: VoidFunc\n  next: Listener | null\n  prev: Listener | null\n}\n\nfunction createListenerCollection() {\n  let first: Listener | null = null\n  let last: Listener | null = null\n\n  return {\n    clear() {\n      first = null\n      last = null\n    },\n\n    notify() {\n      batch(() => {\n        let listener = first\n        while (listener) {\n          listener.callback()\n          listener = listener.next\n        }\n      })\n    },\n\n    get() {\n      const listeners: Listener[] = []\n      let listener = first\n      while (listener) {\n        listeners.push(listener)\n        listener = listener.next\n      }\n      return listeners\n    },\n\n    subscribe(callback: () => void) {\n      let isSubscribed = true\n\n      const listener: Listener = (last = {\n        callback,\n        next: null,\n        prev: last,\n      })\n\n      if (listener.prev) {\n        listener.prev.next = listener\n      } else {\n        first = listener\n      }\n\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return\n        isSubscribed = false\n\n        if (listener.next) {\n          listener.next.prev = listener.prev\n        } else {\n          last = listener.prev\n        }\n        if (listener.prev) {\n          listener.prev.next = listener.next\n        } else {\n          first = listener.next\n        }\n      }\n    },\n  }\n}\n\ntype ListenerCollection = ReturnType<typeof createListenerCollection>\n\nexport interface Subscription {\n  addNestedSub: (listener: VoidFunc) => VoidFunc\n  notifyNestedSubs: VoidFunc\n  handleChangeWrapper: VoidFunc\n  isSubscribed: () => boolean\n  onStateChange?: VoidFunc | null\n  trySubscribe: VoidFunc\n  tryUnsubscribe: VoidFunc\n  getListeners: () => ListenerCollection\n}\n\nconst nullListeners = {\n  notify() {},\n  get: () => [],\n} as unknown as ListenerCollection\n\nexport function createSubscription(store: any, parentSub?: Subscription) {\n  let unsubscribe: VoidFunc | undefined\n  let listeners: ListenerCollection = nullListeners\n\n  // Reasons to keep the subscription active\n  let subscriptionsAmount = 0\n\n  // Is this specific subscription subscribed (or only nested ones?)\n  let selfSubscribed = false\n\n  function addNestedSub(listener: () => void) {\n    trySubscribe()\n\n    const cleanupListener = listeners.subscribe(listener)\n\n    // cleanup nested sub\n    let removed = false\n    return () => {\n      if (!removed) {\n        removed = true\n        cleanupListener()\n        tryUnsubscribe()\n      }\n    }\n  }\n\n  function notifyNestedSubs() {\n    listeners.notify()\n  }\n\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange()\n    }\n  }\n\n  function isSubscribed() {\n    return selfSubscribed\n  }\n\n  function trySubscribe() {\n    subscriptionsAmount++\n    if (!unsubscribe) {\n      unsubscribe = parentSub\n        ? parentSub.addNestedSub(handleChangeWrapper)\n        : store.subscribe(handleChangeWrapper)\n\n      listeners = createListenerCollection()\n    }\n  }\n\n  function tryUnsubscribe() {\n    subscriptionsAmount--\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe()\n      unsubscribe = undefined\n      listeners.clear()\n      listeners = nullListeners\n    }\n  }\n\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true\n      trySubscribe()\n    }\n  }\n\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false\n      tryUnsubscribe()\n    }\n  }\n\n  const subscription: Subscription = {\n    addNestedSub,\n    notifyNestedSubs,\n    handleChangeWrapper,\n    isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: () => listeners,\n  }\n\n  return subscription\n}\n","import { React } from '../utils/react'\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n\n// Matches logic in React's `shared/ExecutionEnvironment` file\nexport const canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n)\n\nexport const useIsomorphicLayoutEffect = canUseDOM\n  ? React.useLayoutEffect\n  : React.useEffect\n","function is(x: unknown, y: unknown) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y\n  } else {\n    return x !== x && y !== y\n  }\n}\n\nexport default function shallowEqual(objA: any, objB: any) {\n  if (is(objA, objB)) return true\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  const keysA = Object.keys(objA)\n  const keysB = Object.keys(objB)\n\n  if (keysA.length !== keysB.length) return false\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i]) ||\n      !is(objA[keysA[i]], objB[keysA[i]])\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n","// Copied directly from:\n// https://github.com/mridgway/hoist-non-react-statics/blob/main/src/index.js\n// https://unpkg.com/browse/@types/hoist-non-react-statics@3.3.1/index.d.ts\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nimport type * as React from 'react'\nimport { ForwardRef, Memo, isMemo } from '../utils/react-is'\n\nconst REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true,\n} as const\n\nconst KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true,\n} as const\n\nconst FORWARD_REF_STATICS = {\n  $$typeof: true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n} as const\n\nconst MEMO_STATICS = {\n  $$typeof: true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true,\n} as const\n\nconst TYPE_STATICS = {\n  [ForwardRef]: FORWARD_REF_STATICS,\n  [Memo]: MEMO_STATICS,\n} as const\n\nfunction getStatics(component: any) {\n  // React v16.11 and below\n  if (isMemo(component)) {\n    return MEMO_STATICS\n  }\n\n  // React v16.12 and above\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS\n}\n\nexport type NonReactStatics<\n  S extends React.ComponentType<any>,\n  C extends {\n    [key: string]: true\n  } = {}\n> = {\n  [key in Exclude<\n    keyof S,\n    S extends React.MemoExoticComponent<any>\n      ? keyof typeof MEMO_STATICS | keyof C\n      : S extends React.ForwardRefExoticComponent<any>\n      ? keyof typeof FORWARD_REF_STATICS | keyof C\n      : keyof typeof REACT_STATICS | keyof typeof KNOWN_STATICS | keyof C\n  >]: S[key]\n}\n\nconst defineProperty = Object.defineProperty\nconst getOwnPropertyNames = Object.getOwnPropertyNames\nconst getOwnPropertySymbols = Object.getOwnPropertySymbols\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor\nconst getPrototypeOf = Object.getPrototypeOf\nconst objectPrototype = Object.prototype\n\nexport default function hoistNonReactStatics<\n  T extends React.ComponentType<any>,\n  S extends React.ComponentType<any>,\n  C extends {\n    [key: string]: true\n  } = {}\n>(targetComponent: T, sourceComponent: S): T & NonReactStatics<S, C> {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n\n    if (objectPrototype) {\n      const inheritedComponent = getPrototypeOf(sourceComponent)\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent)\n      }\n    }\n\n    let keys: (string | symbol)[] = getOwnPropertyNames(sourceComponent)\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent))\n    }\n\n    const targetStatics = getStatics(targetComponent)\n    const sourceStatics = getStatics(sourceComponent)\n\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i]\n      if (\n        !KNOWN_STATICS[key as keyof typeof KNOWN_STATICS] &&\n        !(sourceStatics && sourceStatics[key as keyof typeof sourceStatics]) &&\n        !(targetStatics && targetStatics[key as keyof typeof targetStatics])\n      ) {\n        const descriptor = getOwnPropertyDescriptor(sourceComponent, key)\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor!)\n        } catch (e) {\n          // ignore\n        }\n      }\n    }\n  }\n\n  return targetComponent as any\n}\n","/* eslint-disable valid-jsdoc, @typescript-eslint/no-unused-vars */\nimport type { ComponentType } from 'react'\nimport { React } from '../utils/react'\nimport { isValidElementType, isContextConsumer } from '../utils/react-is'\n\nimport type { Store } from 'redux'\n\nimport type {\n  ConnectedComponent,\n  InferableComponentEnhancer,\n  InferableComponentEnhancerWithProps,\n  ResolveThunks,\n  DispatchProp,\n  ConnectPropsMaybeWithoutContext,\n} from '../types'\n\nimport type {\n  MapStateToPropsParam,\n  MapDispatchToPropsParam,\n  MergeProps,\n  MapDispatchToPropsNonObject,\n  SelectorFactoryOptions,\n} from '../connect/selectorFactory'\nimport defaultSelectorFactory from '../connect/selectorFactory'\nimport { mapDispatchToPropsFactory } from '../connect/mapDispatchToProps'\nimport { mapStateToPropsFactory } from '../connect/mapStateToProps'\nimport { mergePropsFactory } from '../connect/mergeProps'\n\nimport type { Subscription } from '../utils/Subscription'\nimport { createSubscription } from '../utils/Subscription'\nimport { useIsomorphicLayoutEffect } from '../utils/useIsomorphicLayoutEffect'\nimport shallowEqual from '../utils/shallowEqual'\nimport hoistStatics from '../utils/hoistStatics'\nimport warning from '../utils/warning'\n\nimport type {\n  ReactReduxContextValue,\n  ReactReduxContextInstance,\n} from './Context'\nimport { ReactReduxContext } from './Context'\n\nimport type { uSES } from '../utils/useSyncExternalStore'\nimport { notInitialized } from '../utils/useSyncExternalStore'\n\nlet useSyncExternalStore = notInitialized as uSES\nexport const initializeConnect = (fn: uSES) => {\n  useSyncExternalStore = fn\n}\n\n// Define some constant arrays just to avoid re-creating these\nconst EMPTY_ARRAY: [unknown, number] = [null, 0]\nconst NO_SUBSCRIPTION_ARRAY = [null, null]\n\n// Attempts to stringify whatever not-really-a-component value we were given\n// for logging in an error message\nconst stringifyComponent = (Comp: unknown) => {\n  try {\n    return JSON.stringify(Comp)\n  } catch (err) {\n    return String(Comp)\n  }\n}\n\ntype EffectFunc = (...args: any[]) => void | ReturnType<React.EffectCallback>\n\n// This is \"just\" a `useLayoutEffect`, but with two modifications:\n// - we need to fall back to `useEffect` in SSR to avoid annoying warnings\n// - we extract this to a separate function to avoid closing over values\n//   and causing memory leaks\nfunction useIsomorphicLayoutEffectWithArgs(\n  effectFunc: EffectFunc,\n  effectArgs: any[],\n  dependencies?: React.DependencyList,\n) {\n  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies)\n}\n\n// Effect callback, extracted: assign the latest props values to refs for later usage\nfunction captureWrapperProps(\n  lastWrapperProps: React.MutableRefObject<unknown>,\n  lastChildProps: React.MutableRefObject<unknown>,\n  renderIsScheduled: React.MutableRefObject<boolean>,\n  wrapperProps: unknown,\n  // actualChildProps: unknown,\n  childPropsFromStoreUpdate: React.MutableRefObject<unknown>,\n  notifyNestedSubs: () => void,\n) {\n  // We want to capture the wrapper props and child props we used for later comparisons\n  lastWrapperProps.current = wrapperProps\n  renderIsScheduled.current = false\n\n  // If the render was from a store update, clear out that reference and cascade the subscriber update\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null\n    notifyNestedSubs()\n  }\n}\n\n// Effect callback, extracted: subscribe to the Redux store or nearest connected ancestor,\n// check for updates after dispatched actions, and trigger re-renders.\nfunction subscribeUpdates(\n  shouldHandleStateChanges: boolean,\n  store: Store,\n  subscription: Subscription,\n  childPropsSelector: (state: unknown, props: unknown) => unknown,\n  lastWrapperProps: React.MutableRefObject<unknown>,\n  lastChildProps: React.MutableRefObject<unknown>,\n  renderIsScheduled: React.MutableRefObject<boolean>,\n  isMounted: React.MutableRefObject<boolean>,\n  childPropsFromStoreUpdate: React.MutableRefObject<unknown>,\n  notifyNestedSubs: () => void,\n  // forceComponentUpdateDispatch: React.Dispatch<any>,\n  additionalSubscribeListener: () => void,\n) {\n  // If we're not subscribed to the store, nothing to do here\n  if (!shouldHandleStateChanges) return () => {}\n\n  // Capture values for checking if and when this component unmounts\n  let didUnsubscribe = false\n  let lastThrownError: Error | null = null\n\n  // We'll run this callback every time a store subscription update propagates to this component\n  const checkForUpdates = () => {\n    if (didUnsubscribe || !isMounted.current) {\n      // Don't run stale listeners.\n      // Redux doesn't guarantee unsubscriptions happen until next dispatch.\n      return\n    }\n\n    // TODO We're currently calling getState ourselves here, rather than letting `uSES` do it\n    const latestStoreState = store.getState()\n\n    let newChildProps, error\n    try {\n      // Actually run the selector with the most recent store state and wrapper props\n      // to determine what the child props should be\n      newChildProps = childPropsSelector(\n        latestStoreState,\n        lastWrapperProps.current,\n      )\n    } catch (e) {\n      error = e\n      lastThrownError = e as Error | null\n    }\n\n    if (!error) {\n      lastThrownError = null\n    }\n\n    // If the child props haven't changed, nothing to do here - cascade the subscription update\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs()\n      }\n    } else {\n      // Save references to the new child props.  Note that we track the \"child props from store update\"\n      // as a ref instead of a useState/useReducer because we need a way to determine if that value has\n      // been processed.  If this went into useState/useReducer, we couldn't clear out the value without\n      // forcing another re-render, which we don't want.\n      lastChildProps.current = newChildProps\n      childPropsFromStoreUpdate.current = newChildProps\n      renderIsScheduled.current = true\n\n      // TODO This is hacky and not how `uSES` is meant to be used\n      // Trigger the React `useSyncExternalStore` subscriber\n      additionalSubscribeListener()\n    }\n  }\n\n  // Actually subscribe to the nearest connected ancestor (or store)\n  subscription.onStateChange = checkForUpdates\n  subscription.trySubscribe()\n\n  // Pull data from the store after first render in case the store has\n  // changed since we began.\n  checkForUpdates()\n\n  const unsubscribeWrapper = () => {\n    didUnsubscribe = true\n    subscription.tryUnsubscribe()\n    subscription.onStateChange = null\n\n    if (lastThrownError) {\n      // It's possible that we caught an error due to a bad mapState function, but the\n      // parent re-rendered without this component and we're about to unmount.\n      // This shouldn't happen as long as we do top-down subscriptions correctly, but\n      // if we ever do those wrong, this throw will surface the error in our tests.\n      // In that case, throw the error from here so it doesn't get lost.\n      throw lastThrownError\n    }\n  }\n\n  return unsubscribeWrapper\n}\n\n// Reducer initial state creation for our update reducer\nconst initStateUpdates = () => EMPTY_ARRAY\n\nexport interface ConnectProps {\n  /** A custom Context instance that the component can use to access the store from an alternate Provider using that same Context instance */\n  context?: ReactReduxContextInstance\n  /** A Redux store instance to be used for subscriptions instead of the store from a Provider */\n  store?: Store\n}\n\ninterface InternalConnectProps extends ConnectProps {\n  reactReduxForwardedRef?: React.ForwardedRef<unknown>\n}\n\nfunction strictEqual(a: unknown, b: unknown) {\n  return a === b\n}\n\n/**\n * Infers the type of props that a connector will inject into a component.\n */\nexport type ConnectedProps<TConnector> =\n  TConnector extends InferableComponentEnhancerWithProps<\n    infer TInjectedProps,\n    any\n  >\n    ? unknown extends TInjectedProps\n      ? TConnector extends InferableComponentEnhancer<infer TInjectedProps>\n        ? TInjectedProps\n        : never\n      : TInjectedProps\n    : never\n\nexport interface ConnectOptions<\n  State = unknown,\n  TStateProps = {},\n  TOwnProps = {},\n  TMergedProps = {}\n> {\n  forwardRef?: boolean\n  context?: typeof ReactReduxContext\n  areStatesEqual?: (\n    nextState: State,\n    prevState: State,\n    nextOwnProps: TOwnProps,\n    prevOwnProps: TOwnProps\n  ) => boolean\n\n  areOwnPropsEqual?: (\n    nextOwnProps: TOwnProps,\n    prevOwnProps: TOwnProps\n  ) => boolean\n\n  areStatePropsEqual?: (\n    nextStateProps: TStateProps,\n    prevStateProps: TStateProps\n  ) => boolean\n  areMergedPropsEqual?: (\n    nextMergedProps: TMergedProps,\n    prevMergedProps: TMergedProps\n  ) => boolean\n}\n\n/**\n * Connects a React component to a Redux store.\n *\n * - Without arguments, just wraps the component, without changing the behavior / props\n *\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\n * is to override ownProps (as stated in the docs), so what remains is everything that's\n * not a state or dispatch prop\n *\n * - When 3rd param is passed, we don't know if ownProps propagate and whether they\n * should be valid component props, because it depends on mergeProps implementation.\n * As such, it is the user's responsibility to extend ownProps interface from state or\n * dispatch props or both when applicable\n *\n * @param mapStateToProps\n * @param mapDispatchToProps\n * @param mergeProps\n * @param options\n */\nexport interface Connect<DefaultState = unknown> {\n  // tslint:disable:no-unnecessary-generics\n  (): InferableComponentEnhancer<DispatchProp>\n\n  /** mapState only */\n  <TStateProps = {}, no_dispatch = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>\n  ): InferableComponentEnhancerWithProps<TStateProps & DispatchProp, TOwnProps>\n\n  /** mapDispatch only (as a function) */\n  <no_state = {}, TDispatchProps = {}, TOwnProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>\n  ): InferableComponentEnhancerWithProps<TDispatchProps, TOwnProps>\n\n  /** mapDispatch only (as an object) */\n  <no_state = {}, TDispatchProps = {}, TOwnProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>\n  ): InferableComponentEnhancerWithProps<\n    ResolveThunks<TDispatchProps>,\n    TOwnProps\n  >\n\n  /** mapState and mapDispatch (as a function)*/\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>\n  ): InferableComponentEnhancerWithProps<\n    TStateProps & TDispatchProps,\n    TOwnProps\n  >\n\n  /** mapState and mapDispatch (nullish) */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: null | undefined\n  ): InferableComponentEnhancerWithProps<TStateProps, TOwnProps>\n\n  /** mapState and mapDispatch (as an object) */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>\n  ): InferableComponentEnhancerWithProps<\n    TStateProps & ResolveThunks<TDispatchProps>,\n    TOwnProps\n  >\n\n  /** mergeProps only */\n  <no_state = {}, no_dispatch = {}, TOwnProps = {}, TMergedProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: null | undefined,\n    mergeProps: MergeProps<undefined, DispatchProp, TOwnProps, TMergedProps>\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\n\n  /** mapState and mergeProps */\n  <\n    TStateProps = {},\n    no_dispatch = {},\n    TOwnProps = {},\n    TMergedProps = {},\n    State = DefaultState\n  >(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: null | undefined,\n    mergeProps: MergeProps<TStateProps, DispatchProp, TOwnProps, TMergedProps>\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\n\n  /** mapDispatch (as a object) and mergeProps */\n  <no_state = {}, TDispatchProps = {}, TOwnProps = {}, TMergedProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n    mergeProps: MergeProps<undefined, TDispatchProps, TOwnProps, TMergedProps>\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\n\n  /** mapState and options */\n  <TStateProps = {}, no_dispatch = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: null | undefined,\n    mergeProps: null | undefined,\n    options: ConnectOptions<State, TStateProps, TOwnProps>\n  ): InferableComponentEnhancerWithProps<DispatchProp & TStateProps, TOwnProps>\n\n  /** mapDispatch (as a function) and options */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>,\n    mergeProps: null | undefined,\n    options: ConnectOptions<{}, TStateProps, TOwnProps>\n  ): InferableComponentEnhancerWithProps<TDispatchProps, TOwnProps>\n\n  /** mapDispatch (as an object) and options*/\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n    mergeProps: null | undefined,\n    options: ConnectOptions<{}, TStateProps, TOwnProps>\n  ): InferableComponentEnhancerWithProps<\n    ResolveThunks<TDispatchProps>,\n    TOwnProps\n  >\n\n  /** mapState,  mapDispatch (as a function), and options */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>,\n    mergeProps: null | undefined,\n    options: ConnectOptions<State, TStateProps, TOwnProps>\n  ): InferableComponentEnhancerWithProps<\n    TStateProps & TDispatchProps,\n    TOwnProps\n  >\n\n  /** mapState,  mapDispatch (as an object), and options */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n    mergeProps: null | undefined,\n    options: ConnectOptions<State, TStateProps, TOwnProps>\n  ): InferableComponentEnhancerWithProps<\n    TStateProps & ResolveThunks<TDispatchProps>,\n    TOwnProps\n  >\n\n  /** mapState, mapDispatch, mergeProps, and options */\n  <\n    TStateProps = {},\n    TDispatchProps = {},\n    TOwnProps = {},\n    TMergedProps = {},\n    State = DefaultState\n  >(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n    mergeProps: MergeProps<\n      TStateProps,\n      TDispatchProps,\n      TOwnProps,\n      TMergedProps\n    >,\n    options?: ConnectOptions<State, TStateProps, TOwnProps, TMergedProps>\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\n  // tslint:enable:no-unnecessary-generics\n}\n\nlet hasWarnedAboutDeprecatedPureOption = false\n\n/**\n * Connects a React component to a Redux store.\n *\n * - Without arguments, just wraps the component, without changing the behavior / props\n *\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\n * is to override ownProps (as stated in the docs), so what remains is everything that's\n * not a state or dispatch prop\n *\n * - When 3rd param is passed, we don't know if ownProps propagate and whether they\n * should be valid component props, because it depends on mergeProps implementation.\n * As such, it is the user's responsibility to extend ownProps interface from state or\n * dispatch props or both when applicable\n *\n * @param mapStateToProps A function that extracts values from state\n * @param mapDispatchToProps Setup for dispatching actions\n * @param mergeProps Optional callback to merge state and dispatch props together\n * @param options Options for configuring the connection\n *\n */\nfunction connect<\n  TStateProps = {},\n  TDispatchProps = {},\n  TOwnProps = {},\n  TMergedProps = {},\n  State = unknown\n>(\n  mapStateToProps?: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n  mapDispatchToProps?: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n  mergeProps?: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,\n  {\n    // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n    // @ts-ignore\n    pure,\n    areStatesEqual = strictEqual,\n    areOwnPropsEqual = shallowEqual,\n    areStatePropsEqual = shallowEqual,\n    areMergedPropsEqual = shallowEqual,\n\n    // use React's forwardRef to expose a ref of the wrapped component\n    forwardRef = false,\n\n    // the context consumer to use\n    context = ReactReduxContext,\n  }: ConnectOptions<unknown, unknown, unknown, unknown> = {},\n): unknown {\n  if (process.env.NODE_ENV !== 'production') {\n    if (pure !== undefined && !hasWarnedAboutDeprecatedPureOption) {\n      hasWarnedAboutDeprecatedPureOption = true\n      warning(\n        'The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component',\n      )\n    }\n  }\n\n  const Context = context\n\n  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps)\n  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps)\n  const initMergeProps = mergePropsFactory(mergeProps)\n\n  const shouldHandleStateChanges = Boolean(mapStateToProps)\n\n  const wrapWithConnect = <TProps,>(\n    WrappedComponent: ComponentType<TProps>,\n  ) => {\n    type WrappedComponentProps = TProps &\n      ConnectPropsMaybeWithoutContext<TProps>\n\n    if (process.env.NODE_ENV !== 'production') {\n      const isValid = /*#__PURE__*/ isValidElementType(WrappedComponent)\n      if (!isValid)\n        throw new Error(\n          `You must pass a component to the function returned by connect. Instead received ${stringifyComponent(\n            WrappedComponent,\n          )}`,\n        )\n    }\n\n    const wrappedComponentName =\n      WrappedComponent.displayName || WrappedComponent.name || 'Component'\n\n    const displayName = `Connect(${wrappedComponentName})`\n\n    const selectorFactoryOptions: SelectorFactoryOptions<\n      any,\n      any,\n      any,\n      any,\n      State\n    > = {\n      shouldHandleStateChanges,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps,\n      // @ts-ignore\n      initMapDispatchToProps,\n      initMergeProps,\n      areStatesEqual,\n      areStatePropsEqual,\n      areOwnPropsEqual,\n      areMergedPropsEqual,\n    }\n\n    function ConnectFunction<TOwnProps>(\n      props: InternalConnectProps & TOwnProps,\n    ) {\n      const [propsContext, reactReduxForwardedRef, wrapperProps] =\n        React.useMemo(() => {\n          // Distinguish between actual \"data\" props that were passed to the wrapper component,\n          // and values needed to control behavior (forwarded refs, alternate context instances).\n          // To maintain the wrapperProps object reference, memoize this destructuring.\n          const { reactReduxForwardedRef, ...wrapperProps } = props\n          return [props.context, reactReduxForwardedRef, wrapperProps]\n        }, [props])\n\n      const ContextToUse: ReactReduxContextInstance = React.useMemo(() => {\n        // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.\n        // Memoize the check that determines which context instance we should use.\n        let ResultContext = Context\n        if (propsContext?.Consumer) {\n          if (process.env.NODE_ENV !== 'production') {\n            const isValid = /*#__PURE__*/ isContextConsumer(\n              // @ts-ignore\n              <propsContext.Consumer />,\n            )\n            if (!isValid) {\n              throw new Error(\n                'You must pass a valid React context consumer as `props.context`',\n              )\n            }\n            ResultContext = propsContext\n          }\n        }\n        return ResultContext\n      }, [propsContext, Context])\n\n      // Retrieve the store and ancestor subscription via context, if available\n      const contextValue = React.useContext(ContextToUse)\n\n      // The store _must_ exist as either a prop or in context.\n      // We'll check to see if it _looks_ like a Redux store first.\n      // This allows us to pass through a `store` prop that is just a plain value.\n      const didStoreComeFromProps =\n        Boolean(props.store) &&\n        Boolean(props.store!.getState) &&\n        Boolean(props.store!.dispatch)\n      const didStoreComeFromContext =\n        Boolean(contextValue) && Boolean(contextValue!.store)\n\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        !didStoreComeFromProps &&\n        !didStoreComeFromContext\n      ) {\n        throw new Error(\n          `Could not find \"store\" in the context of ` +\n            `\"${displayName}\". Either wrap the root component in a <Provider>, ` +\n            `or pass a custom React context provider to <Provider> and the corresponding ` +\n            `React context consumer to ${displayName} in connect options.`,\n        )\n      }\n\n      // Based on the previous check, one of these must be true\n      const store: Store = didStoreComeFromProps\n        ? props.store!\n        : contextValue!.store\n\n      const getServerState = didStoreComeFromContext\n        ? contextValue!.getServerState\n        : store.getState\n\n      const childPropsSelector = React.useMemo(() => {\n        // The child props selector needs the store reference as an input.\n        // Re-create this selector whenever the store changes.\n        return defaultSelectorFactory(store.dispatch, selectorFactoryOptions)\n      }, [store])\n\n      const [subscription, notifyNestedSubs] = React.useMemo(() => {\n        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY\n\n        // This Subscription's source should match where store came from: props vs. context. A component\n        // connected to the store via props shouldn't use subscription from context, or vice versa.\n        const subscription = createSubscription(\n          store,\n          didStoreComeFromProps ? undefined : contextValue!.subscription,\n        )\n\n        // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in\n        // the middle of the notification loop, where `subscription` will then be null. This can\n        // probably be avoided if Subscription's listeners logic is changed to not call listeners\n        // that have been unsubscribed in the  middle of the notification loop.\n        const notifyNestedSubs =\n          subscription.notifyNestedSubs.bind(subscription)\n\n        return [subscription, notifyNestedSubs]\n      }, [store, didStoreComeFromProps, contextValue])\n\n      // Determine what {store, subscription} value should be put into nested context, if necessary,\n      // and memoize that value to avoid unnecessary context updates.\n      const overriddenContextValue = React.useMemo(() => {\n        if (didStoreComeFromProps) {\n          // This component is directly subscribed to a store from props.\n          // We don't want descendants reading from this store - pass down whatever\n          // the existing context value is from the nearest connected ancestor.\n          return contextValue!\n        }\n\n        // Otherwise, put this component's subscription instance into context, so that\n        // connected descendants won't update until after this component is done\n        return {\n          ...contextValue,\n          subscription,\n        } as ReactReduxContextValue\n      }, [didStoreComeFromProps, contextValue, subscription])\n\n      // Set up refs to coordinate values between the subscription effect and the render logic\n      const lastChildProps = React.useRef<unknown>()\n      const lastWrapperProps = React.useRef(wrapperProps)\n      const childPropsFromStoreUpdate = React.useRef<unknown>()\n      const renderIsScheduled = React.useRef(false)\n      const isProcessingDispatch = React.useRef(false)\n      const isMounted = React.useRef(false)\n\n      const latestSubscriptionCallbackError = React.useRef<Error>()\n\n      useIsomorphicLayoutEffect(() => {\n        isMounted.current = true\n        return () => {\n          isMounted.current = false\n        }\n      }, [])\n\n      const actualChildPropsSelector = React.useMemo(() => {\n        const selector = () => {\n          // Tricky logic here:\n          // - This render may have been triggered by a Redux store update that produced new child props\n          // - However, we may have gotten new wrapper props after that\n          // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.\n          // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.\n          // So, we'll use the child props from store update only if the wrapper props are the same as last time.\n          if (\n            childPropsFromStoreUpdate.current &&\n            wrapperProps === lastWrapperProps.current\n          ) {\n            return childPropsFromStoreUpdate.current\n          }\n\n          // TODO We're reading the store directly in render() here. Bad idea?\n          // This will likely cause Bad Things (TM) to happen in Concurrent Mode.\n          // Note that we do this because on renders _not_ caused by store updates, we need the latest store state\n          // to determine what the child props should be.\n          return childPropsSelector(store.getState(), wrapperProps)\n        }\n        return selector\n      }, [store, wrapperProps])\n\n      // We need this to execute synchronously every time we re-render. However, React warns\n      // about useLayoutEffect in SSR, so we try to detect environment and fall back to\n      // just useEffect instead to avoid the warning, since neither will run anyway.\n\n      const subscribeForReact = React.useMemo(() => {\n        const subscribe = (reactListener: () => void) => {\n          if (!subscription) {\n            return () => {}\n          }\n\n          return subscribeUpdates(\n            shouldHandleStateChanges,\n            store,\n            subscription,\n            // @ts-ignore\n            childPropsSelector,\n            lastWrapperProps,\n            lastChildProps,\n            renderIsScheduled,\n            isMounted,\n            childPropsFromStoreUpdate,\n            notifyNestedSubs,\n            reactListener,\n          )\n        }\n\n        return subscribe\n      }, [subscription])\n\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\n        lastWrapperProps,\n        lastChildProps,\n        renderIsScheduled,\n        wrapperProps,\n        childPropsFromStoreUpdate,\n        notifyNestedSubs,\n      ])\n\n      let actualChildProps: Record<string, unknown>\n\n      try {\n        actualChildProps = useSyncExternalStore(\n          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n          subscribeForReact,\n          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n          actualChildPropsSelector,\n          getServerState\n            ? () => childPropsSelector(getServerState(), wrapperProps)\n            : actualChildPropsSelector,\n        )\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          // eslint-disable-next-line no-extra-semi\n          ;(\n            err as Error\n          ).message += `\\nThe error may be correlated with this previous error:\\n${latestSubscriptionCallbackError.current.stack}\\n\\n`\n        }\n\n        throw err\n      }\n\n      useIsomorphicLayoutEffect(() => {\n        latestSubscriptionCallbackError.current = undefined\n        childPropsFromStoreUpdate.current = undefined\n        lastChildProps.current = actualChildProps\n      })\n\n      // Now that all that's done, we can finally try to actually render the child component.\n      // We memoize the elements for the rendered child component as an optimization.\n      const renderedWrappedComponent = React.useMemo(() => {\n        return (\n          // @ts-ignore\n          <WrappedComponent\n            {...actualChildProps}\n            ref={reactReduxForwardedRef}\n          />\n        )\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps])\n\n      // If React sees the exact same element reference as last time, it bails out of re-rendering\n      // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.\n      const renderedChild = React.useMemo(() => {\n        if (shouldHandleStateChanges) {\n          // If this component is subscribed to store updates, we need to pass its own\n          // subscription instance down to our descendants. That means rendering the same\n          // Context instance, and putting a different value into the context.\n          return (\n            <ContextToUse.Provider value={overriddenContextValue}>\n              {renderedWrappedComponent}\n            </ContextToUse.Provider>\n          )\n        }\n\n        return renderedWrappedComponent\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue])\n\n      return renderedChild\n    }\n\n    const _Connect = React.memo(ConnectFunction)\n\n    type ConnectedWrapperComponent = typeof _Connect & {\n      WrappedComponent: typeof WrappedComponent\n    }\n\n    // Add a hacky cast to get the right output type\n    const Connect = _Connect as unknown as ConnectedComponent<\n      typeof WrappedComponent,\n      WrappedComponentProps\n    >\n    Connect.WrappedComponent = WrappedComponent\n    Connect.displayName = ConnectFunction.displayName = displayName\n\n    if (forwardRef) {\n      const _forwarded = React.forwardRef(function forwardConnectRef(\n        props,\n        ref,\n      ) {\n        // @ts-ignore\n        return <Connect {...props} reactReduxForwardedRef={ref} />\n      })\n\n      const forwarded = _forwarded as ConnectedWrapperComponent\n      forwarded.displayName = displayName\n      forwarded.WrappedComponent = WrappedComponent\n      return /*#__PURE__*/ hoistStatics(forwarded, WrappedComponent)\n    }\n\n    return /*#__PURE__*/ hoistStatics(Connect, WrappedComponent)\n  }\n\n  return wrapWithConnect\n}\n\nexport default connect as Connect\n","import type { Context, ReactNode } from 'react'\nimport { React } from '../utils/react'\nimport type { Action, Store, UnknownAction } from 'redux'\nimport type { DevModeCheckFrequency } from '../hooks/useSelector'\nimport { createSubscription } from '../utils/Subscription'\nimport { useIsomorphicLayoutEffect } from '../utils/useIsomorphicLayoutEffect'\nimport type { ReactReduxContextValue } from './Context'\nimport { ReactReduxContext } from './Context'\n\nexport interface ProviderProps<\n  A extends Action<string> = UnknownAction,\n  S = unknown\n> {\n  /**\n   * The single Redux store in your application.\n   */\n  store: Store<S, A>\n\n  /**\n   * An optional server state snapshot. Will be used during initial hydration render if available, to ensure that the UI output is consistent with the HTML generated on the server.\n   */\n  serverState?: S\n\n  /**\n   * Optional context to be used internally in react-redux. Use React.createContext() to create a context to be used.\n   * If this is used, you'll need to customize `connect` by supplying the same context provided to the Provider.\n   * Set the initial value to null, and the hooks will error\n   * if this is not overwritten by Provider.\n   */\n  context?: Context<ReactReduxContextValue<S, A> | null>\n\n  /**\n   * Determines the frequency of stability checks for all selectors.\n   * This setting overrides the global configuration for\n   * the `useSelector` stability check, allowing you to specify how often\n   * these checks should occur in development mode.\n   *\n   * @since 8.1.0\n   */\n  stabilityCheck?: DevModeCheckFrequency\n\n  /**\n   * Determines the frequency of identity function checks for all selectors.\n   * This setting overrides the global configuration for\n   * the `useSelector` identity function check, allowing you to specify how often\n   * these checks should occur in development mode.\n   *\n   * **Note**: Previously referred to as `noopCheck`.\n   *\n   * @since 9.0.0\n   */\n  identityFunctionCheck?: DevModeCheckFrequency\n\n  children: ReactNode\n}\n\nfunction Provider<A extends Action<string> = UnknownAction, S = unknown>({\n  store,\n  context,\n  children,\n  serverState,\n  stabilityCheck = 'once',\n  identityFunctionCheck = 'once',\n}: ProviderProps<A, S>) {\n  const contextValue = React.useMemo(() => {\n    const subscription = createSubscription(store)\n    return {\n      store,\n      subscription,\n      getServerState: serverState ? () => serverState : undefined,\n      stabilityCheck,\n      identityFunctionCheck,\n    }\n  }, [store, serverState, stabilityCheck, identityFunctionCheck])\n\n  const previousState = React.useMemo(() => store.getState(), [store])\n\n  useIsomorphicLayoutEffect(() => {\n    const { subscription } = contextValue\n    subscription.onStateChange = subscription.notifyNestedSubs\n    subscription.trySubscribe()\n\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs()\n    }\n    return () => {\n      subscription.tryUnsubscribe()\n      subscription.onStateChange = undefined\n    }\n  }, [contextValue, previousState])\n\n  const Context = context || ReactReduxContext\n\n  // @ts-ignore 'AnyAction' is assignable to the constraint of type 'A', but 'A' could be instantiated with a different subtype\n  return <Context.Provider value={contextValue}>{children}</Context.Provider>\n}\n\nexport default Provider\n","import type { Context } from 'react'\nimport type { Action, Store } from 'redux'\nimport type { ReactReduxContextValue } from '../components/Context'\nimport { ReactReduxContext } from '../components/Context'\nimport {\n  createReduxContextHook,\n  useReduxContext as useDefaultReduxContext,\n} from './useReduxContext'\n\n/**\n * Represents a type that extracts the action type from a given Redux store.\n *\n * @template StoreType - The specific type of the Redux store.\n *\n * @since 9.1.0\n * @internal\n */\nexport type ExtractStoreActionType<StoreType extends Store> =\n  StoreType extends Store<any, infer ActionType> ? ActionType : never\n\n/**\n * Represents a custom hook that provides access to the Redux store.\n *\n * @template StoreType - The specific type of the Redux store that gets returned.\n *\n * @since 9.1.0\n * @public\n */\nexport interface UseStore<StoreType extends Store> {\n  /**\n   * Returns the Redux store instance.\n   *\n   * @returns The Redux store instance.\n   */\n  (): StoreType\n\n  /**\n   * Returns the Redux store instance with specific state and action types.\n   *\n   * @returns The Redux store with the specified state and action types.\n   *\n   * @template StateType - The specific type of the state used in the store.\n   * @template ActionType - The specific type of the actions used in the store.\n   */\n  <\n    StateType extends ReturnType<StoreType['getState']> = ReturnType<\n      StoreType['getState']\n    >,\n    ActionType extends Action = ExtractStoreActionType<Store>\n  >(): Store<StateType, ActionType>\n\n  /**\n   * Creates a \"pre-typed\" version of {@linkcode useStore useStore}\n   * where the type of the Redux `store` is predefined.\n   *\n   * This allows you to set the `store` type once, eliminating the need to\n   * specify it with every {@linkcode useStore useStore} call.\n   *\n   * @returns A pre-typed `useStore` with the store type already defined.\n   *\n   * @example\n   * ```ts\n   * export const useAppStore = useStore.withTypes<AppStore>()\n   * ```\n   *\n   * @template OverrideStoreType - The specific type of the Redux store that gets returned.\n   *\n   * @since 9.1.0\n   */\n  withTypes: <\n    OverrideStoreType extends StoreType\n  >() => UseStore<OverrideStoreType>\n}\n\n/**\n * Hook factory, which creates a `useStore` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useStore` hook bound to the specified context.\n */\nexport function createStoreHook<\n  StateType = unknown,\n  ActionType extends Action = Action\n>(\n  // @ts-ignore\n  context?: Context<ReactReduxContextValue<\n    StateType,\n    ActionType\n  > | null> = ReactReduxContext\n) {\n  const useReduxContext =\n    context === ReactReduxContext\n      ? useDefaultReduxContext\n      : // @ts-ignore\n        createReduxContextHook(context)\n  const useStore = () => {\n    const { store } = useReduxContext()\n    return store\n  }\n\n  Object.assign(useStore, {\n    withTypes: () => useStore,\n  })\n\n  return useStore as UseStore<Store<StateType, ActionType>>\n}\n\n/**\n * A hook to access the redux store.\n *\n * @returns {any} the redux store\n *\n * @example\n *\n * import React from 'react'\n * import { useStore } from 'react-redux'\n *\n * export const ExampleComponent = () => {\n *   const store = useStore()\n *   return <div>{store.getState()}</div>\n * }\n */\nexport const useStore = /*#__PURE__*/ createStoreHook()\n","import type { Context } from 'react'\nimport type { Action, Dispatch, UnknownAction } from 'redux'\n\nimport type { ReactReduxContextValue } from '../components/Context'\nimport { ReactReduxContext } from '../components/Context'\nimport { createStoreHook, useStore as useDefaultStore } from './useStore'\n\n/**\n * Represents a custom hook that provides a dispatch function\n * from the Redux store.\n *\n * @template DispatchType - The specific type of the dispatch function.\n *\n * @since 9.1.0\n * @public\n */\nexport interface UseDispatch<\n  DispatchType extends Dispatch<UnknownAction> = Dispatch<UnknownAction>\n> {\n  /**\n   * Returns the dispatch function from the Redux store.\n   *\n   * @returns The dispatch function from the Redux store.\n   *\n   * @template AppDispatch - The specific type of the dispatch function.\n   */\n  <AppDispatch extends DispatchType = DispatchType>(): AppDispatch\n\n  /**\n   * Creates a \"pre-typed\" version of {@linkcode useDispatch useDispatch}\n   * where the type of the `dispatch` function is predefined.\n   *\n   * This allows you to set the `dispatch` type once, eliminating the need to\n   * specify it with every {@linkcode useDispatch useDispatch} call.\n   *\n   * @returns A pre-typed `useDispatch` with the dispatch type already defined.\n   *\n   * @example\n   * ```ts\n   * export const useAppDispatch = useDispatch.withTypes<AppDispatch>()\n   * ```\n   *\n   * @template OverrideDispatchType - The specific type of the dispatch function.\n   *\n   * @since 9.1.0\n   */\n  withTypes: <\n    OverrideDispatchType extends DispatchType\n  >() => UseDispatch<OverrideDispatchType>\n}\n\n/**\n * Hook factory, which creates a `useDispatch` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useDispatch` hook bound to the specified context.\n */\nexport function createDispatchHook<\n  StateType = unknown,\n  ActionType extends Action = UnknownAction\n>(\n  // @ts-ignore\n  context?: Context<ReactReduxContextValue<\n    StateType,\n    ActionType\n  > | null> = ReactReduxContext\n) {\n  const useStore =\n    context === ReactReduxContext ? useDefaultStore : createStoreHook(context)\n\n  const useDispatch = () => {\n    const store = useStore()\n    return store.dispatch\n  }\n\n  Object.assign(useDispatch, {\n    withTypes: () => useDispatch,\n  })\n\n  return useDispatch as UseDispatch<Dispatch<ActionType>>\n}\n\n/**\n * A hook to access the redux `dispatch` function.\n *\n * @returns {any|function} redux store's `dispatch` function\n *\n * @example\n *\n * import React, { useCallback } from 'react'\n * import { useDispatch } from 'react-redux'\n *\n * export const CounterComponent = ({ value }) => {\n *   const dispatch = useDispatch()\n *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])\n *   return (\n *     <div>\n *       <span>{value}</span>\n *       <button onClick={increaseCounter}>Increase counter</button>\n *     </div>\n *   )\n * }\n */\nexport const useDispatch = /*#__PURE__*/ createDispatchHook()\n","import connect from './components/connect'\nexport type {\n  Connect,\n  ConnectProps,\n  ConnectedProps,\n} from './components/connect'\n\nimport shallowEqual from './utils/shallowEqual'\n\nimport Provider from './components/Provider'\nimport { defaultNoopBatch } from './utils/batch'\n\nexport { ReactReduxContext } from './components/Context'\nexport type { ReactReduxContextValue } from './components/Context'\n\nexport type { ProviderProps } from './components/Provider'\n\nexport type {\n  MapDispatchToProps,\n  MapDispatchToPropsFactory,\n  MapDispatchToPropsFunction,\n  MapDispatchToPropsNonObject,\n  MapDispatchToPropsParam,\n  MapStateToProps,\n  MapStateToPropsFactory,\n  MapStateToPropsParam,\n  MergeProps,\n  Selector,\n  SelectorFactory,\n} from './connect/selectorFactory'\n\nexport { createDispatchHook, useDispatch } from './hooks/useDispatch'\nexport type { UseDispatch } from './hooks/useDispatch'\n\nexport { createSelectorHook, useSelector } from './hooks/useSelector'\nexport type { UseSelector } from './hooks/useSelector'\n\nexport { createStoreHook, useStore } from './hooks/useStore'\nexport type { UseStore } from './hooks/useStore'\n\nexport type { Subscription } from './utils/Subscription'\n\nexport * from './types'\n\n/**\n * @deprecated As of React 18, batching is enabled by default for ReactDOM and React Native.\n * This is now a no-op that immediately runs the callback.\n */\nconst batch = defaultNoopBatch\n\nexport { Provider, batch, connect, shallowEqual }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}